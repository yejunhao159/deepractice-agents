# 9.5 ä¸ AgentX/PromptX é›†æˆ

> è®©è®¤çŸ¥æ¶æ„åœ¨çœŸå®ç¯å¢ƒä¸­è¿è¡Œ

å‰é¢æˆ‘ä»¬å®ç°äº† Monogent çš„æ ¸å¿ƒç»„ä»¶ï¼šExperience æ•°æ®ç»“æ„ã€ä¸ƒé˜¶æ®µç®¡é“ã€åŒåŸºè´¨ç­–ç•¥ã€‚ç°åœ¨æ˜¯æ—¶å€™å°†å®ƒä»¬æ•´åˆåˆ°å®Œæ•´çš„æ™ºèƒ½ä½“ç³»ç»Ÿä¸­äº†ã€‚

æœ¬èŠ‚å°†å±•ç¤ºå¦‚ä½•å°† Monogent ä¸ AgentX è¿è¡Œæ—¶å’Œ PromptX è®°å¿†ç³»ç»Ÿé›†æˆï¼Œæ„å»ºä¸€ä¸ªçœŸæ­£å…·æœ‰è®¤çŸ¥èƒ½åŠ›çš„æ™ºèƒ½ä½“ã€‚

---

## 9.5.1 ä¸‰å±‚æ¶æ„å›é¡¾

åœ¨å¼€å§‹é›†æˆä¹‹å‰ï¼Œè®©æˆ‘ä»¬å›é¡¾ä¸‰ä¸ªç³»ç»Ÿçš„èŒè´£ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    è®¤çŸ¥æ™ºèƒ½ä½“å®Œæ•´æ¶æ„                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                   Monogent å±‚                        â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚   â”‚
â”‚  â”‚  â”‚Experienceâ”‚  â”‚ Pipeline â”‚  â”‚Substrateâ”‚            â”‚   â”‚
â”‚  â”‚  â”‚  Chain   â”‚  â”‚7 Stages â”‚  â”‚ Manager â”‚            â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚   â”‚
â”‚  â”‚                 è®¤çŸ¥å¤„ç†å±‚                           â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                         â”‚                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                   PromptX å±‚                         â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚   â”‚
â”‚  â”‚  â”‚  Role   â”‚  â”‚ Engram  â”‚  â”‚  Tool   â”‚            â”‚   â”‚
â”‚  â”‚  â”‚ System  â”‚  â”‚ Memory  â”‚  â”‚ Runtime â”‚            â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚   â”‚
â”‚  â”‚                 èƒ½åŠ›å¢å¼ºå±‚                           â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                         â”‚                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                   AgentX å±‚                          â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚   â”‚
â”‚  â”‚  â”‚ System  â”‚  â”‚Containerâ”‚  â”‚  MCP    â”‚            â”‚   â”‚
â”‚  â”‚  â”‚   Bus   â”‚  â”‚Lifecycleâ”‚  â”‚ Client  â”‚            â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚   â”‚
â”‚  â”‚                 è¿è¡Œæ—¶å±‚                             â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**èŒè´£åˆ†å·¥**ï¼š

| å±‚çº§ | ç³»ç»Ÿ | æ ¸å¿ƒèŒè´£ |
|-----|------|---------|
| è¿è¡Œæ—¶å±‚ | AgentX | äº‹ä»¶é©±åŠ¨ã€ç”Ÿå‘½å‘¨æœŸç®¡ç†ã€å¤–éƒ¨é€šä¿¡ |
| èƒ½åŠ›å¢å¼ºå±‚ | PromptX | è§’è‰²ç³»ç»Ÿã€è®°å¿†å­˜å‚¨ã€å·¥å…·è°ƒç”¨ |
| è®¤çŸ¥å¤„ç†å±‚ | Monogent | ä½“éªŒå¤„ç†ã€è®¤çŸ¥ç®¡é“ã€åŸºè´¨é€‰æ‹© |

---

## 9.5.2 ä¸ PromptX Engram é›†æˆ

Monogent çš„è®°å¿†æ“ä½œéœ€è¦ä¸ PromptX çš„ Engram ç³»ç»Ÿå¯¹æ¥ã€‚

### åˆ›å»º Engram é€‚é…å™¨

```typescript
// src/integration/engram-adapter.ts

import { Experience, Stage } from '../core/experience';

/**
 * Engram è®°å¿†æ¡ç›®
 */
interface EngramEntry {
  content: string;
  schema: string;
  strength: number;
  type: 'ATOMIC' | 'LINK' | 'PATTERN';
}

/**
 * PromptX MCP å®¢æˆ·ç«¯æ¥å£
 */
interface PromptXClient {
  recall(role: string, query: string | null, mode?: string): Promise<RecallResult>;
  remember(role: string, engrams: EngramEntry[]): Promise<void>;
}

interface RecallResult {
  memories: Array<{
    content: string;
    schema: string;
    strength: number;
    relevance: number;
  }>;
  networkGraph: string;
}

/**
 * Engram é€‚é…å™¨
 * å°† Monogent çš„è®°å¿†æ“ä½œè½¬æ¢ä¸º PromptX Engram è°ƒç”¨
 */
export class EngramAdapter {
  private client: PromptXClient;
  private roleId: string;

  constructor(client: PromptXClient, roleId: string) {
    this.client = client;
    this.roleId = roleId;
  }

  /**
   * æ£€ç´¢è®°å¿†ï¼ˆç”¨äº Activation é˜¶æ®µï¼‰
   */
  async retrieveMemories(
    keywords: string[],
    mode: 'focused' | 'balanced' | 'creative' = 'balanced'
  ): Promise<Experience[]> {
    // æ„å»ºæŸ¥è¯¢
    const query = keywords.length > 0 ? keywords.join(' ') : null;

    // è°ƒç”¨ PromptX recall
    const result = await this.client.recall(this.roleId, query, mode);

    // å°† Engram è®°å¿†è½¬æ¢ä¸º Experience
    return result.memories.map((memory, index) => ({
      id: `memory-${Date.now()}-${index}`,
      content: {
        text: memory.content,
        schema: memory.schema,
        strength: memory.strength,
        relevance: memory.relevance
      },
      substrate: 'computation' as const,
      metadata: {
        timestamp: Date.now(),
        source: 'engram-recall',
        stage: Stage.Activation,
        custom: {
          originalStrength: memory.strength,
          relevanceScore: memory.relevance
        }
      }
    }));
  }

  /**
   * è·å–è®°å¿†ç½‘ç»œå…¨æ™¯ï¼ˆç”¨äº DMN æ¨¡å¼ï¼‰
   */
  async getMemoryNetwork(): Promise<{
    experiences: Experience[];
    networkGraph: string;
  }> {
    // ä½¿ç”¨ null query è§¦å‘ DMN æ¨¡å¼
    const result = await this.client.recall(this.roleId, null, 'balanced');

    const experiences = result.memories.map((memory, index) => ({
      id: `dmn-${Date.now()}-${index}`,
      content: {
        text: memory.content,
        schema: memory.schema,
        strength: memory.strength
      },
      substrate: 'computation' as const,
      metadata: {
        timestamp: Date.now(),
        source: 'engram-dmn',
        stage: Stage.Activation
      }
    }));

    return {
      experiences,
      networkGraph: result.networkGraph
    };
  }

  /**
   * å­˜å‚¨æ–°è®°å¿†ï¼ˆç”¨äº Integration é˜¶æ®µåï¼‰
   */
  async storeMemory(experience: Experience): Promise<void> {
    // ä» Experience æå– Engram æ¡ç›®
    const engram = this.experienceToEngram(experience);

    if (engram) {
      await this.client.remember(this.roleId, [engram]);
    }
  }

  /**
   * æ‰¹é‡å­˜å‚¨è®°å¿†
   */
  async storeMemories(experiences: Experience[]): Promise<void> {
    const engrams = experiences
      .map(exp => this.experienceToEngram(exp))
      .filter((e): e is EngramEntry => e !== null);

    if (engrams.length > 0) {
      await this.client.remember(this.roleId, engrams);
    }
  }

  /**
   * å°† Experience è½¬æ¢ä¸º Engram æ¡ç›®
   */
  private experienceToEngram(experience: Experience): EngramEntry | null {
    const content = experience.content;

    // æ ¹æ®å†…å®¹ç±»å‹ç¡®å®š Engram ç±»å‹
    let type: 'ATOMIC' | 'LINK' | 'PATTERN' = 'ATOMIC';
    let schema: string;
    let text: string;

    if (typeof content === 'string') {
      text = content;
      schema = this.extractKeywords(content).join(' ');
    } else if (content && typeof content === 'object') {
      text = content.text || content.summary || JSON.stringify(content);
      schema = content.schema || content.keywords?.join(' ') || '';

      // åˆ¤æ–­ç±»å‹
      if (content.relations || content.links) {
        type = 'LINK';
      } else if (content.pattern || content.flow) {
        type = 'PATTERN';
      }
    } else {
      return null;
    }

    // è®¡ç®—å¼ºåº¦
    const strength = this.calculateStrength(experience);

    return {
      content: text,
      schema,
      strength,
      type
    };
  }

  /**
   * æå–å…³é”®è¯
   */
  private extractKeywords(text: string): string[] {
    // ç®€å•çš„å…³é”®è¯æå–
    const words = text.split(/\s+/);
    const stopWords = new Set(['çš„', 'æ˜¯', 'åœ¨', 'å’Œ', 'äº†', 'the', 'a', 'an', 'is', 'are']);

    return words
      .filter(w => w.length > 1 && !stopWords.has(w.toLowerCase()))
      .slice(0, 5);
  }

  /**
   * è®¡ç®—è®°å¿†å¼ºåº¦
   */
  private calculateStrength(experience: Experience): number {
    let strength = 0.5; // åŸºç¡€å¼ºåº¦

    // æ ¹æ®æ¥æºè°ƒæ•´
    const source = experience.metadata.source;
    if (source === 'user-input') {
      strength += 0.2; // ç”¨æˆ·è¾“å…¥æ›´é‡è¦
    }

    // æ ¹æ®é˜¶æ®µè°ƒæ•´
    if (experience.metadata.stage === Stage.Integration) {
      strength += 0.1; // å·²æ•´åˆçš„ä¿¡æ¯æ›´é‡è¦
    }

    // æ ¹æ®è‡ªå®šä¹‰å…ƒæ•°æ®è°ƒæ•´
    if (experience.metadata.custom?.importance) {
      strength = Math.min(1, strength + experience.metadata.custom.importance * 0.2);
    }

    return Math.min(1, Math.max(0, strength));
  }
}
```

### é›†æˆåˆ°è®¤çŸ¥ç®¡é“

```typescript
// src/integration/cognitive-pipeline-with-engram.ts

import { Experience, Stage } from '../core/experience';
import { CognitivePipeline, PipelineContext } from '../pipeline';
import { EngramAdapter } from './engram-adapter';

/**
 * å¢å¼ºçš„è®¤çŸ¥ç®¡é“ï¼ˆé›†æˆ Engramï¼‰
 */
export class EngramCognitivePipeline extends CognitivePipeline {
  private engramAdapter: EngramAdapter;

  constructor(
    processors: Map<Stage, any>,
    engramAdapter: EngramAdapter
  ) {
    super(processors);
    this.engramAdapter = engramAdapter;
  }

  /**
   * é‡å†™ Activation é˜¶æ®µï¼Œä½¿ç”¨ Engram æ£€ç´¢
   */
  protected async processActivation(
    experience: Experience,
    context: PipelineContext
  ): Promise<Experience> {
    // ä» Representation é˜¶æ®µè·å–å…³é”®è¯
    const keywords = experience.content.keywords || [];

    // ä½¿ç”¨ Engram æ£€ç´¢ç›¸å…³è®°å¿†
    const memories = await this.engramAdapter.retrieveMemories(
      keywords,
      'balanced'
    );

    // å°†è®°å¿†æ·»åŠ åˆ°ä¸Šä¸‹æ–‡
    context.activatedMemories = memories;

    // è¿”å›æ›´æ–°åçš„ Experience
    return {
      ...experience,
      content: {
        ...experience.content,
        activatedNodes: memories.map(m => ({
          id: m.id,
          content: m.content.text,
          strength: m.content.strength,
          relevance: m.content.relevance
        }))
      },
      metadata: {
        ...experience.metadata,
        stage: Stage.Activation
      }
    };
  }

  /**
   * é‡å†™ Integration é˜¶æ®µï¼Œå­˜å‚¨æ–°è®°å¿†
   */
  protected async processIntegration(
    experience: Experience,
    context: PipelineContext
  ): Promise<Experience> {
    // è°ƒç”¨åŸå§‹æ•´åˆé€»è¾‘
    const integrated = await super.processIntegration(experience, context);

    // å¦‚æœäº§ç”Ÿäº†æœ‰ä»·å€¼çš„è¾“å‡ºï¼Œå­˜å‚¨ä¸ºæ–°è®°å¿†
    if (this.shouldStoreAsMemory(integrated)) {
      await this.engramAdapter.storeMemory(integrated);
    }

    return integrated;
  }

  /**
   * åˆ¤æ–­æ˜¯å¦åº”è¯¥å­˜å‚¨ä¸ºè®°å¿†
   */
  private shouldStoreAsMemory(experience: Experience): boolean {
    // åªå­˜å‚¨æœ‰å®è´¨å†…å®¹çš„ä½“éªŒ
    if (!experience.content) return false;

    // æ£€æŸ¥æ˜¯å¦æœ‰æ–°ä¿¡æ¯
    const isNewInformation = experience.metadata.custom?.isNew !== false;

    // æ£€æŸ¥é‡è¦æ€§
    const importance = experience.metadata.custom?.importance || 0;

    return isNewInformation && importance > 0.3;
  }
}
```

---

## 9.5.3 ä¸ AgentX è¿è¡Œæ—¶é›†æˆ

AgentX æä¾›äº‹ä»¶é©±åŠ¨çš„è¿è¡Œæ—¶ç¯å¢ƒã€‚æˆ‘ä»¬éœ€è¦å°† Monogent çš„è®¤çŸ¥å¤„ç†é›†æˆåˆ° AgentX çš„äº‹ä»¶æµä¸­ã€‚

### åˆ›å»ºè®¤çŸ¥å¤„ç†å™¨

```typescript
// src/integration/agentx-cognitive-processor.ts

import { Experience, Stage, createExperience } from '../core/experience';
import { EngramCognitivePipeline } from './cognitive-pipeline-with-engram';
import { SubstrateManager } from '../substrate/substrate-manager';

/**
 * AgentX äº‹ä»¶ç±»å‹
 */
interface AgentXEvent {
  type: 'message' | 'tool_call' | 'tool_result' | 'state_change';
  payload: any;
  timestamp: number;
}

/**
 * AgentX æ¶ˆæ¯äº‹ä»¶
 */
interface MessageEvent extends AgentXEvent {
  type: 'message';
  payload: {
    role: 'user' | 'assistant';
    content: string;
  };
}

/**
 * è®¤çŸ¥å¤„ç†å™¨é…ç½®
 */
interface CognitiveProcessorConfig {
  pipeline: EngramCognitivePipeline;
  substrateManager: SubstrateManager;
  roleId: string;
}

/**
 * AgentX è®¤çŸ¥å¤„ç†å™¨
 * å°†è®¤çŸ¥ç®¡é“é›†æˆåˆ° AgentX äº‹ä»¶æµ
 */
export class AgentXCognitiveProcessor {
  private pipeline: EngramCognitivePipeline;
  private substrateManager: SubstrateManager;
  private roleId: string;
  private experienceChain: Experience[] = [];

  constructor(config: CognitiveProcessorConfig) {
    this.pipeline = config.pipeline;
    this.substrateManager = config.substrateManager;
    this.roleId = config.roleId;
  }

  /**
   * å¤„ç† AgentX äº‹ä»¶
   */
  async processEvent(event: AgentXEvent): Promise<Experience | null> {
    switch (event.type) {
      case 'message':
        return this.processMessage(event as MessageEvent);
      case 'tool_result':
        return this.processToolResult(event);
      default:
        return null;
    }
  }

  /**
   * å¤„ç†æ¶ˆæ¯äº‹ä»¶
   */
  private async processMessage(event: MessageEvent): Promise<Experience> {
    const { role, content } = event.payload;

    // åˆ›å»ºåˆå§‹ Experience
    const inputExperience = createExperience(
      {
        type: 'message',
        role,
        text: content
      },
      {
        source: role === 'user' ? 'user-input' : 'assistant-output',
        stage: Stage.Sensation
      }
    );

    // é€šè¿‡è®¤çŸ¥ç®¡é“å¤„ç†
    const processedExperience = await this.pipeline.process(inputExperience);

    // æ·»åŠ åˆ°ä½“éªŒé“¾
    this.addToChain(processedExperience);

    return processedExperience;
  }

  /**
   * å¤„ç†å·¥å…·è°ƒç”¨ç»“æœ
   */
  private async processToolResult(event: AgentXEvent): Promise<Experience> {
    const { toolName, result } = event.payload;

    // åˆ›å»ºå·¥å…·ç»“æœ Experience
    const toolExperience = createExperience(
      {
        type: 'tool_result',
        tool: toolName,
        result
      },
      {
        source: `tool:${toolName}`,
        stage: Stage.Sensation
      }
    );

    // ç®€åŒ–å¤„ç†ï¼ˆå·¥å…·ç»“æœé€šå¸¸ä¸éœ€è¦å®Œæ•´çš„è®¤çŸ¥ç®¡é“ï¼‰
    const processed = await this.substrateManager.process(toolExperience);

    this.addToChain(processed.result as Experience);

    return processed.result as Experience;
  }

  /**
   * æ·»åŠ åˆ°ä½“éªŒé“¾
   */
  private addToChain(experience: Experience): void {
    if (this.experienceChain.length > 0) {
      const lastExperience = this.experienceChain[this.experienceChain.length - 1];
      // å»ºç«‹é“¾æ¥ï¼ˆè¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…åº”è¯¥ä½¿ç”¨ macroEvolveï¼‰
      (experience as any).prev = lastExperience;
      (lastExperience as any).next = experience;
    }

    this.experienceChain.push(experience);

    // é™åˆ¶é“¾é•¿åº¦ï¼Œé¿å…å†…å­˜æº¢å‡º
    if (this.experienceChain.length > 100) {
      this.experienceChain = this.experienceChain.slice(-50);
    }
  }

  /**
   * è·å–å½“å‰ä¸Šä¸‹æ–‡ï¼ˆç”¨äºç”Ÿæˆå›å¤ï¼‰
   */
  getContext(): {
    recentExperiences: Experience[];
    activatedMemories: Experience[];
  } {
    return {
      recentExperiences: this.experienceChain.slice(-10),
      activatedMemories: this.experienceChain
        .flatMap(exp => exp.content?.activatedNodes || [])
        .slice(-20)
    };
  }

  /**
   * æ¸…ç©ºä½“éªŒé“¾
   */
  clearChain(): void {
    this.experienceChain = [];
  }
}
```

### åˆ›å»ºå®Œæ•´çš„è®¤çŸ¥æ™ºèƒ½ä½“

```typescript
// src/integration/cognitive-agent.ts

import { AgentXCognitiveProcessor } from './agentx-cognitive-processor';
import { EngramCognitivePipeline } from './cognitive-pipeline-with-engram';
import { EngramAdapter } from './engram-adapter';
import { SubstrateManager } from '../substrate/substrate-manager';
import { HybridSelector } from '../substrate/selectors';
import { createDefaultPipeline } from '../pipeline/factory';

/**
 * è®¤çŸ¥æ™ºèƒ½ä½“é…ç½®
 */
interface CognitiveAgentConfig {
  roleId: string;
  promptxClient: any;  // PromptX MCP å®¢æˆ·ç«¯
  claudeClient: any;   // Claude API å®¢æˆ·ç«¯
}

/**
 * è®¤çŸ¥æ™ºèƒ½ä½“
 * æ•´åˆ AgentX + PromptX + Monogent çš„å®Œæ•´æ™ºèƒ½ä½“
 */
export class CognitiveAgent {
  private config: CognitiveAgentConfig;
  private processor: AgentXCognitiveProcessor;
  private engramAdapter: EngramAdapter;
  private isInitialized: boolean = false;

  constructor(config: CognitiveAgentConfig) {
    this.config = config;
    this.engramAdapter = new EngramAdapter(
      config.promptxClient,
      config.roleId
    );
  }

  /**
   * åˆå§‹åŒ–æ™ºèƒ½ä½“
   */
  async initialize(): Promise<void> {
    if (this.isInitialized) return;

    // åˆ›å»ºåŸºè´¨ç®¡ç†å™¨
    const substrateManager = new SubstrateManager({
      claudeClient: this.config.claudeClient,
      selector: new HybridSelector()
    });

    // åˆ›å»ºé»˜è®¤å¤„ç†å™¨
    const processors = createDefaultPipeline({
      claudeClient: this.config.claudeClient
    });

    // åˆ›å»ºå¢å¼ºç®¡é“
    const pipeline = new EngramCognitivePipeline(
      processors,
      this.engramAdapter
    );

    // åˆ›å»ºå¤„ç†å™¨
    this.processor = new AgentXCognitiveProcessor({
      pipeline,
      substrateManager,
      roleId: this.config.roleId
    });

    this.isInitialized = true;

    console.log(`è®¤çŸ¥æ™ºèƒ½ä½“å·²åˆå§‹åŒ– [è§’è‰²: ${this.config.roleId}]`);
  }

  /**
   * å¤„ç†ç”¨æˆ·è¾“å…¥
   */
  async processInput(input: string): Promise<{
    response: string;
    reasoning: string[];
    memories: any[];
  }> {
    if (!this.isInitialized) {
      await this.initialize();
    }

    // åˆ›å»ºæ¶ˆæ¯äº‹ä»¶
    const event = {
      type: 'message' as const,
      payload: {
        role: 'user' as const,
        content: input
      },
      timestamp: Date.now()
    };

    // é€šè¿‡è®¤çŸ¥å¤„ç†å™¨å¤„ç†
    const experience = await this.processor.processEvent(event);

    // è·å–ä¸Šä¸‹æ–‡
    const context = this.processor.getContext();

    // æå–å“åº”
    const response = experience?.content?.response ||
                     experience?.content?.output ||
                     'æŠ±æ­‰ï¼Œæˆ‘æ— æ³•ç”Ÿæˆæœ‰æ•ˆçš„å›å¤ã€‚';

    // æå–æ¨ç†è¿‡ç¨‹
    const reasoning = this.extractReasoning(experience);

    // æå–æ¿€æ´»çš„è®°å¿†
    const memories = context.activatedMemories.map(m => ({
      content: m.content?.text || m.content,
      relevance: m.content?.relevance || 0
    }));

    return {
      response,
      reasoning,
      memories
    };
  }

  /**
   * æå–æ¨ç†è¿‡ç¨‹
   */
  private extractReasoning(experience: any): string[] {
    const reasoning: string[] = [];

    if (experience?.content?.perception) {
      reasoning.push(`æ„å›¾è¯†åˆ«: ${experience.content.perception.intent}`);
    }

    if (experience?.content?.representation) {
      reasoning.push(`è¯­ä¹‰è¡¨å¾: ${experience.content.representation.keywords?.join(', ')}`);
    }

    if (experience?.content?.activatedNodes?.length > 0) {
      reasoning.push(`æ¿€æ´»è®°å¿†: ${experience.content.activatedNodes.length} ä¸ªèŠ‚ç‚¹`);
    }

    if (experience?.content?.associations?.length > 0) {
      reasoning.push(`è”æƒ³æ‰©å±•: ${experience.content.associations.length} ä¸ªå…³è”`);
    }

    return reasoning;
  }

  /**
   * è·å–è®°å¿†ç½‘ç»œå¿«ç…§
   */
  async getMemorySnapshot(): Promise<{
    networkGraph: string;
    topMemories: any[];
  }> {
    const result = await this.engramAdapter.getMemoryNetwork();

    return {
      networkGraph: result.networkGraph,
      topMemories: result.experiences.slice(0, 10).map(exp => ({
        content: exp.content.text,
        strength: exp.content.strength
      }))
    };
  }

  /**
   * æ‰‹åŠ¨å­˜å‚¨è®°å¿†
   */
  async remember(content: string, keywords: string[]): Promise<void> {
    const experience = {
      id: `manual-${Date.now()}`,
      content: {
        text: content,
        keywords
      },
      substrate: 'computation' as const,
      metadata: {
        timestamp: Date.now(),
        source: 'manual-input',
        stage: 'Integration' as any,
        custom: {
          importance: 0.8
        }
      }
    };

    await this.engramAdapter.storeMemory(experience);
  }

  /**
   * é‡ç½®æ™ºèƒ½ä½“çŠ¶æ€
   */
  reset(): void {
    this.processor?.clearChain();
    console.log('æ™ºèƒ½ä½“çŠ¶æ€å·²é‡ç½®');
  }
}
```

---

## 9.5.4 å®Œæ•´ä½¿ç”¨ç¤ºä¾‹

### åŸºæœ¬ä½¿ç”¨

```typescript
// examples/cognitive-agent-demo.ts

import { CognitiveAgent } from '../src/integration/cognitive-agent';
import Anthropic from '@anthropic-ai/sdk';

async function main() {
  // åˆ›å»º Claude å®¢æˆ·ç«¯
  const claudeClient = new Anthropic({
    apiKey: process.env.ANTHROPIC_API_KEY
  });

  // åˆ›å»º PromptX å®¢æˆ·ç«¯ï¼ˆæ¨¡æ‹Ÿï¼‰
  const promptxClient = createPromptXClient();

  // åˆ›å»ºè®¤çŸ¥æ™ºèƒ½ä½“
  const agent = new CognitiveAgent({
    roleId: 'assistant',
    promptxClient,
    claudeClient
  });

  // åˆå§‹åŒ–
  await agent.initialize();

  console.log('='.repeat(60));
  console.log('è®¤çŸ¥æ™ºèƒ½ä½“æ¼”ç¤º');
  console.log('='.repeat(60));

  // å¯¹è¯ 1
  console.log('\nğŸ“ ç”¨æˆ·: ä»€ä¹ˆæ˜¯äº‹ä»¶é©±åŠ¨æ¶æ„ï¼Ÿ');
  const result1 = await agent.processInput('ä»€ä¹ˆæ˜¯äº‹ä»¶é©±åŠ¨æ¶æ„ï¼Ÿ');

  console.log('\nğŸ¤– å›å¤:', result1.response);
  console.log('\nğŸ“Š æ¨ç†è¿‡ç¨‹:');
  result1.reasoning.forEach(r => console.log(`  - ${r}`));
  console.log('\nğŸ’¾ æ¿€æ´»è®°å¿†:', result1.memories.length, 'æ¡');

  // å¯¹è¯ 2ï¼ˆåŸºäºå‰æ–‡ï¼‰
  console.log('\n' + '-'.repeat(60));
  console.log('\nğŸ“ ç”¨æˆ·: è¿™å’Œ AgentX æœ‰ä»€ä¹ˆå…³ç³»ï¼Ÿ');
  const result2 = await agent.processInput('è¿™å’Œ AgentX æœ‰ä»€ä¹ˆå…³ç³»ï¼Ÿ');

  console.log('\nğŸ¤– å›å¤:', result2.response);
  console.log('\nğŸ“Š æ¨ç†è¿‡ç¨‹:');
  result2.reasoning.forEach(r => console.log(`  - ${r}`));

  // æŸ¥çœ‹è®°å¿†ç½‘ç»œ
  console.log('\n' + '-'.repeat(60));
  console.log('\nğŸ§  è®°å¿†ç½‘ç»œå¿«ç…§:');
  const snapshot = await agent.getMemorySnapshot();
  console.log(snapshot.networkGraph);

  // æ‰‹åŠ¨å­˜å‚¨è®°å¿†
  await agent.remember(
    'AgentX ä½¿ç”¨äº‹ä»¶é©±åŠ¨æ¶æ„å®ç°æ™ºèƒ½ä½“è¿è¡Œæ—¶',
    ['AgentX', 'äº‹ä»¶é©±åŠ¨', 'è¿è¡Œæ—¶']
  );
  console.log('\nâœ… æ–°è®°å¿†å·²å­˜å‚¨');
}

/**
 * åˆ›å»ºæ¨¡æ‹Ÿçš„ PromptX å®¢æˆ·ç«¯
 */
function createPromptXClient() {
  const memories: any[] = [
    {
      content: 'äº‹ä»¶é©±åŠ¨æ¶æ„æ˜¯ä¸€ç§è½¯ä»¶è®¾è®¡æ¨¡å¼ï¼Œç»„ä»¶é€šè¿‡äº‹ä»¶è¿›è¡Œé€šä¿¡',
      schema: 'äº‹ä»¶é©±åŠ¨ æ¶æ„ è®¾è®¡æ¨¡å¼',
      strength: 0.8
    },
    {
      content: 'AgentX æ˜¯ Deepractice å¼€å‘çš„äº‹ä»¶é©±åŠ¨æ™ºèƒ½ä½“æ¡†æ¶',
      schema: 'AgentX Deepractice æ¡†æ¶',
      strength: 0.9
    }
  ];

  return {
    async recall(role: string, query: string | null, mode?: string) {
      // æ¨¡æ‹Ÿè®°å¿†æ£€ç´¢
      if (query === null) {
        return {
          memories: memories.map(m => ({ ...m, relevance: 0.5 })),
          networkGraph: `
è®°å¿†ç½‘ç»œ:
â”œâ”€â”€ äº‹ä»¶é©±åŠ¨ â”€â”€â”¬â”€â”€ æ¶æ„
â”‚              â””â”€â”€ è®¾è®¡æ¨¡å¼
â””â”€â”€ AgentX â”€â”€â”€â”€â”¬â”€â”€ Deepractice
               â””â”€â”€ æ¡†æ¶
          `
        };
      }

      // æ ¹æ®æŸ¥è¯¢è¿‡æ»¤
      const keywords = query.toLowerCase().split(' ');
      const filtered = memories.filter(m =>
        keywords.some(k => m.content.toLowerCase().includes(k))
      );

      return {
        memories: filtered.map(m => ({
          ...m,
          relevance: 0.7 + Math.random() * 0.3
        })),
        networkGraph: ''
      };
    },

    async remember(role: string, engrams: any[]) {
      memories.push(...engrams.map(e => ({
        ...e,
        strength: e.strength || 0.7
      })));
      console.log(`[PromptX] å­˜å‚¨äº† ${engrams.length} æ¡æ–°è®°å¿†`);
    }
  };
}

main().catch(console.error);
```

### é«˜çº§åœºæ™¯ï¼šå¤šè½®å¯¹è¯

```typescript
// examples/multi-turn-conversation.ts

import { CognitiveAgent } from '../src/integration/cognitive-agent';

async function runConversation(agent: CognitiveAgent) {
  const conversation = [
    'ä½ å¥½ï¼Œæˆ‘æƒ³å­¦ä¹ æ™ºèƒ½ä½“å¼€å‘',
    'æœ‰å“ªäº›ä¸»æµçš„æ¡†æ¶å¯ä»¥é€‰æ‹©ï¼Ÿ',
    'AgentX å’Œ LangGraph æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ',
    'æˆ‘åº”è¯¥ä»å“ªä¸ªæ¡†æ¶å¼€å§‹å­¦ä¹ ï¼Ÿ',
    'èƒ½ç»™æˆ‘ä¸€ä¸ªç®€å•çš„ç¤ºä¾‹å—ï¼Ÿ'
  ];

  console.log('ğŸ­ å¤šè½®å¯¹è¯æ¼”ç¤º\n');

  for (const input of conversation) {
    console.log(`\nğŸ‘¤ ç”¨æˆ·: ${input}`);

    const result = await agent.processInput(input);

    console.log(`\nğŸ¤– æ™ºèƒ½ä½“: ${result.response}`);

    // æ˜¾ç¤ºè®¤çŸ¥è¿‡ç¨‹
    if (result.reasoning.length > 0) {
      console.log('\n   ğŸ“Š è®¤çŸ¥è¿‡ç¨‹:');
      result.reasoning.forEach(r => console.log(`      ${r}`));
    }

    // æ˜¾ç¤ºä½¿ç”¨çš„è®°å¿†
    if (result.memories.length > 0) {
      console.log(`\n   ğŸ’¾ ä½¿ç”¨äº† ${result.memories.length} æ¡ç›¸å…³è®°å¿†`);
    }

    console.log('\n' + 'â”€'.repeat(50));

    // æ¨¡æ‹Ÿæ€è€ƒæ—¶é—´
    await new Promise(resolve => setTimeout(resolve, 1000));
  }

  // æ˜¾ç¤ºæœ€ç»ˆè®°å¿†ç½‘ç»œ
  console.log('\n\nğŸ“ˆ å¯¹è¯ç»“æŸåçš„è®°å¿†ç½‘ç»œ:');
  const snapshot = await agent.getMemorySnapshot();
  console.log(snapshot.networkGraph);
  console.log(`\næ€»è®°å¿†æ•°: ${snapshot.topMemories.length}`);
}
```

---

## 9.5.5 å®é™…åº”ç”¨æ¨¡å¼

### æ¨¡å¼ 1ï¼šçŸ¥è¯†åŠ©æ‰‹

```typescript
/**
 * çŸ¥è¯†åŠ©æ‰‹ï¼šä¸“æ³¨äºçŸ¥è¯†æ£€ç´¢å’Œè§£ç­”
 */
class KnowledgeAssistant extends CognitiveAgent {
  constructor(config: CognitiveAgentConfig) {
    super({
      ...config,
      roleId: 'knowledge-assistant'
    });
  }

  async answer(question: string): Promise<{
    answer: string;
    sources: string[];
    confidence: number;
  }> {
    // å…ˆæ£€ç´¢è®°å¿†
    const snapshot = await this.getMemorySnapshot();

    // å¤„ç†é—®é¢˜
    const result = await this.processInput(question);

    // æå–æ¥æº
    const sources = result.memories
      .filter(m => m.relevance > 0.5)
      .map(m => m.content);

    // è®¡ç®—ç½®ä¿¡åº¦
    const confidence = sources.length > 0
      ? Math.min(0.9, 0.5 + sources.length * 0.1)
      : 0.3;

    return {
      answer: result.response,
      sources,
      confidence
    };
  }
}
```

### æ¨¡å¼ 2ï¼šä»»åŠ¡æ‰§è¡Œå™¨

```typescript
/**
 * ä»»åŠ¡æ‰§è¡Œå™¨ï¼šä¸“æ³¨äºç†è§£å’Œæ‰§è¡Œä»»åŠ¡
 */
class TaskExecutor extends CognitiveAgent {
  constructor(config: CognitiveAgentConfig) {
    super({
      ...config,
      roleId: 'task-executor'
    });
  }

  async executeTask(task: string): Promise<{
    plan: string[];
    result: any;
    status: 'success' | 'partial' | 'failed';
  }> {
    // åˆ†æä»»åŠ¡
    const analysis = await this.processInput(`åˆ†æä»»åŠ¡: ${task}`);

    // æå–æ‰§è¡Œè®¡åˆ’
    const plan = this.extractPlan(analysis.response);

    // é€æ­¥æ‰§è¡Œ
    const results: any[] = [];
    for (const step of plan) {
      const stepResult = await this.processInput(`æ‰§è¡Œ: ${step}`);
      results.push(stepResult);

      // å­˜å‚¨æ‰§è¡Œç»“æœ
      await this.remember(
        `ä»»åŠ¡æ­¥éª¤å®Œæˆ: ${step}`,
        ['ä»»åŠ¡', 'æ‰§è¡Œ', step.slice(0, 10)]
      );
    }

    return {
      plan,
      result: results,
      status: 'success'
    };
  }

  private extractPlan(response: string): string[] {
    // ç®€å•çš„è®¡åˆ’æå–
    const lines = response.split('\n');
    return lines
      .filter(line => /^\d+\./.test(line.trim()))
      .map(line => line.replace(/^\d+\.\s*/, '').trim());
  }
}
```

### æ¨¡å¼ 3ï¼šå­¦ä¹ å‹åŠ©æ‰‹

```typescript
/**
 * å­¦ä¹ å‹åŠ©æ‰‹ï¼šèƒ½ä»äº¤äº’ä¸­å­¦ä¹ 
 */
class LearningAssistant extends CognitiveAgent {
  private learningRate: number = 0.1;

  async learn(feedback: {
    input: string;
    expectedOutput: string;
    actualOutput: string;
    rating: number;  // 0-1
  }): Promise<void> {
    // å¦‚æœè¯„åˆ†ä½ï¼Œè®°å½•æ”¹è¿›ç‚¹
    if (feedback.rating < 0.7) {
      await this.remember(
        `æ”¹è¿›ç‚¹: å¯¹äº"${feedback.input}"ï¼Œåº”è¯¥å›ç­”"${feedback.expectedOutput}"è€Œä¸æ˜¯"${feedback.actualOutput}"`,
        ['æ”¹è¿›', 'å­¦ä¹ ', 'åé¦ˆ']
      );
    }

    // å¦‚æœè¯„åˆ†é«˜ï¼Œå¼ºåŒ–è®°å¿†
    if (feedback.rating > 0.8) {
      await this.remember(
        `å¥½çš„å›ç­”ç¤ºä¾‹: é—®é¢˜"${feedback.input}"ï¼Œå›ç­”"${feedback.actualOutput}"`,
        ['ç¤ºä¾‹', 'ä¼˜ç§€', 'å›ç­”']
      );
    }
  }

  async processWithLearning(input: string): Promise<{
    response: string;
    shouldAskFeedback: boolean;
  }> {
    const result = await this.processInput(input);

    // åˆ¤æ–­æ˜¯å¦éœ€è¦åé¦ˆ
    const shouldAskFeedback = result.memories.length < 2;  // è®°å¿†ä¸è¶³æ—¶è¯·æ±‚åé¦ˆ

    return {
      response: result.response,
      shouldAskFeedback
    };
  }
}
```

---

## 9.5.6 é›†æˆæ£€æŸ¥æ¸…å•

åœ¨å®Œæˆé›†æˆå‰ï¼Œç¡®ä¿ä»¥ä¸‹å„é¡¹ï¼š

### PromptX é›†æˆ

- [ ] EngramAdapter æ­£ç¡®å®ç° recall å’Œ remember
- [ ] å…³é”®è¯æå–é€»è¾‘ç¬¦åˆä¸šåŠ¡éœ€æ±‚
- [ ] è®°å¿†å¼ºåº¦è®¡ç®—åˆç†
- [ ] Engram ç±»å‹ï¼ˆATOMIC/LINK/PATTERNï¼‰æ­£ç¡®åˆ¤æ–­

### AgentX é›†æˆ

- [ ] äº‹ä»¶ç±»å‹æ­£ç¡®å¤„ç†ï¼ˆmessage/tool_call/tool_resultï¼‰
- [ ] ä½“éªŒé“¾æ­£ç¡®ç»´æŠ¤
- [ ] ä¸Šä¸‹æ–‡æ­£ç¡®èšåˆ
- [ ] ç”Ÿå‘½å‘¨æœŸé’©å­æ­£ç¡®å®ç°

### Monogent æ ¸å¿ƒ

- [ ] ä¸ƒé˜¶æ®µç®¡é“å®Œæ•´å®ç°
- [ ] åŒåŸºè´¨é€‰æ‹©ç­–ç•¥åˆç†
- [ ] Experience æ¼”åŒ–æ­£ç¡®è¿½è¸ª
- [ ] é”™è¯¯å¤„ç†å®Œå–„

---

## 9.5.7 æœ¬èŠ‚å°ç»“

æœ¬èŠ‚å±•ç¤ºäº†å¦‚ä½•å°† Monogent ä¸ AgentX å’Œ PromptX é›†æˆï¼š

1. **ä¸‰å±‚æ¶æ„**ï¼šAgentXï¼ˆè¿è¡Œæ—¶ï¼‰+ PromptXï¼ˆèƒ½åŠ›ï¼‰+ Monogentï¼ˆè®¤çŸ¥ï¼‰
2. **Engram é€‚é…**ï¼šå°†è®¤çŸ¥æ“ä½œè½¬æ¢ä¸º Engram è®°å¿†å­˜å‚¨
3. **AgentX é›†æˆ**ï¼šåœ¨äº‹ä»¶æµä¸­åµŒå…¥è®¤çŸ¥å¤„ç†
4. **å®Œæ•´æ™ºèƒ½ä½“**ï¼šCognitiveAgent ç»Ÿä¸€æ‰€æœ‰èƒ½åŠ›
5. **åº”ç”¨æ¨¡å¼**ï¼šçŸ¥è¯†åŠ©æ‰‹ã€ä»»åŠ¡æ‰§è¡Œå™¨ã€å­¦ä¹ å‹åŠ©æ‰‹

**å…³é”®æ´å¯Ÿ**ï¼š

> è®¤çŸ¥ä¸æ˜¯å­¤ç«‹çš„è®¡ç®—ï¼Œè€Œæ˜¯åœ¨è¿è¡Œç¯å¢ƒä¸­ã€å€ŸåŠ©è®°å¿†ç³»ç»Ÿã€å¤„ç†çœŸå®äº‹ä»¶çš„è¿‡ç¨‹ã€‚

ä¸‹ä¸€èŠ‚æˆ‘ä»¬å°†å¯¹æ•´ç« å†…å®¹è¿›è¡Œæ€»ç»“ï¼Œå¹¶æä¾›å­¦ä¹ æ£€æŸ¥å’Œè¿›é˜¶æŒ‡å¼•ã€‚

---

**[ä¸Šä¸€èŠ‚ï¼š9.4 åŒåŸºè´¨ç­–ç•¥è®¾è®¡](9.4-åŒåŸºè´¨ç­–ç•¥è®¾è®¡.md)** | **[ä¸‹ä¸€èŠ‚ï¼š9.6 æœ¬ç« å°ç»“](9.6-æœ¬ç« å°ç»“.md)**

---

*ä¸‹ä¸€èŠ‚é¢„å‘Šï¼šæˆ‘ä»¬å°†å›é¡¾ Monogent çš„æ ¸å¿ƒæ¦‚å¿µï¼Œæ£€æŸ¥å­¦ä¹ æˆæœï¼Œå¹¶å±•æœ›è®¤çŸ¥æ™ºèƒ½ä½“çš„æœªæ¥å‘å±•æ–¹å‘ã€‚*
