# 9.4 双基质策略设计

> Computation vs Generation：智能选择处理方式

本节将深入双基质模型的设计与实现，学习如何在 Computation（计算）和 Generation（生成）之间智能选择。

---

## 9.4.1 双基质的设计理念

### 为什么需要两种基质

```
┌─────────────────────────────────────────────────────────┐
│                    认知任务谱系                          │
├─────────────────────────────────────────────────────────┤
│                                                          │
│  确定性任务                              创造性任务       │
│  ←─────────────────────────────────────────────────→   │
│                                                          │
│  • 格式转换          • 意图理解          • 创意写作     │
│  • 数据解析          • 信息整合          • 复杂推理     │
│  • 模式匹配          • 记忆检索          • 开放问答     │
│  • 规则执行          • 简单问答          • 代码生成     │
│                                                          │
│  ←── Computation ──→←───── 混合 ─────→←── Generation ─→│
│                                                          │
└─────────────────────────────────────────────────────────┘
```

### 两种基质对比

| 维度 | Computation | Generation |
|-----|-------------|------------|
| **执行方式** | 确定性算法 | 概率性模型 |
| **速度** | 毫秒级 | 秒级 |
| **成本** | 几乎为零 | API 调用费用 |
| **可控性** | 完全可控 | 部分可控 |
| **灵活性** | 需预定义规则 | 可处理未知情况 |
| **适用场景** | 结构化任务 | 语义理解任务 |

---

## 9.4.2 基质接口设计

### 核心接口

```typescript
// substrate.ts

// 基质类型
export type SubstrateType = 'computation' | 'generation';

// 基质接口
export interface Substrate {
  readonly type: SubstrateType;
  process<T, U>(input: T, config?: any): Promise<U>;
  canHandle(input: any): boolean;
  estimateCost(input: any): { time: number; tokens?: number };
}

// 计算基质
export interface ComputationSubstrate extends Substrate {
  type: 'computation';
  registerHandler<T, U>(pattern: string, handler: (input: T) => U): void;
}

// 生成基质
export interface GenerationSubstrate extends Substrate {
  type: 'generation';
  generate(prompt: string, options?: GenerateOptions): Promise<string>;
  stream(prompt: string, options?: GenerateOptions): AsyncGenerator<string>;
}

// 生成选项
export interface GenerateOptions {
  model?: string;
  temperature?: number;
  maxTokens?: number;
  stopSequences?: string[];
  systemPrompt?: string;
}
```

### ComputationEngine 实现

```typescript
// computation-engine.ts
export class ComputationEngine implements ComputationSubstrate {
  readonly type = 'computation' as const;

  private handlers = new Map<string, (input: any) => any>();
  private patterns = new Map<string, RegExp>();

  // 注册处理器
  registerHandler<T, U>(pattern: string, handler: (input: T) => U): void {
    this.handlers.set(pattern, handler);
    this.patterns.set(pattern, new RegExp(pattern));
  }

  // 处理输入
  async process<T, U>(input: T, config?: any): Promise<U> {
    const handler = this.findHandler(input);
    if (!handler) {
      throw new Error(`No handler found for input: ${JSON.stringify(input)}`);
    }
    return handler(input);
  }

  // 检查是否能处理
  canHandle(input: any): boolean {
    return this.findHandler(input) !== null;
  }

  // 估算成本
  estimateCost(input: any): { time: number; tokens?: number } {
    return { time: 1 };  // 毫秒级
  }

  private findHandler(input: any): ((input: any) => any) | null {
    const inputStr = typeof input === 'string' ? input : JSON.stringify(input);

    for (const [pattern, regex] of this.patterns) {
      if (regex.test(inputStr)) {
        return this.handlers.get(pattern)!;
      }
    }
    return null;
  }
}

// 预定义处理器
export function setupDefaultHandlers(engine: ComputationEngine): void {
  // 问候处理
  engine.registerHandler('greeting', (input) => ({
    response: '你好！有什么可以帮你的吗？',
    type: 'greeting'
  }));

  // JSON 解析
  engine.registerHandler('\\{.*\\}', (input) => {
    try {
      return { parsed: JSON.parse(input), success: true };
    } catch {
      return { parsed: null, success: false };
    }
  });

  // 数学计算
  engine.registerHandler('\\d+\\s*[+\\-*/]\\s*\\d+', (input) => {
    try {
      return { result: eval(input), success: true };
    } catch {
      return { result: null, success: false };
    }
  });

  // 时间查询
  engine.registerHandler('现在几点|什么时间|当前时间', () => ({
    time: new Date().toLocaleString('zh-CN'),
    timestamp: Date.now()
  }));
}
```

### GenerationEngine 实现

```typescript
// generation-engine.ts
import Anthropic from '@anthropic-ai/sdk';

export class GenerationEngine implements GenerationSubstrate {
  readonly type = 'generation' as const;

  private client: Anthropic;
  private defaultModel: string;

  constructor(config: { apiKey: string; model?: string }) {
    this.client = new Anthropic({ apiKey: config.apiKey });
    this.defaultModel = config.model || 'claude-sonnet-4-20250514';
  }

  async process<T, U>(input: T, config?: any): Promise<U> {
    const prompt = typeof input === 'string' ? input : JSON.stringify(input);
    const response = await this.generate(prompt, config);
    return response as unknown as U;
  }

  async generate(prompt: string, options?: GenerateOptions): Promise<string> {
    const response = await this.client.messages.create({
      model: options?.model || this.defaultModel,
      max_tokens: options?.maxTokens || 1024,
      messages: [{ role: 'user', content: prompt }],
      system: options?.systemPrompt
    });

    return response.content[0].type === 'text'
      ? response.content[0].text
      : '';
  }

  async *stream(prompt: string, options?: GenerateOptions): AsyncGenerator<string> {
    const stream = await this.client.messages.stream({
      model: options?.model || this.defaultModel,
      max_tokens: options?.maxTokens || 1024,
      messages: [{ role: 'user', content: prompt }],
      system: options?.systemPrompt
    });

    for await (const event of stream) {
      if (event.type === 'content_block_delta' && event.delta.type === 'text_delta') {
        yield event.delta.text;
      }
    }
  }

  canHandle(input: any): boolean {
    return true;  // 生成基质可以处理任何输入
  }

  estimateCost(input: any): { time: number; tokens?: number } {
    const text = typeof input === 'string' ? input : JSON.stringify(input);
    const estimatedTokens = Math.ceil(text.length / 4);
    return {
      time: 1000 + estimatedTokens * 10,  // 估算毫秒
      tokens: estimatedTokens
    };
  }
}
```

---

## 9.4.3 智能选择策略

### SubstrateSelector 接口

```typescript
// substrate-selector.ts
export interface SubstrateSelector {
  select(experience: Experience): SubstrateType;
  explain(experience: Experience): string;
}

// 选择结果
export interface SelectionResult {
  substrate: SubstrateType;
  confidence: number;
  reason: string;
}
```

### 基于规则的选择器

```typescript
// rule-based-selector.ts
export class RuleBasedSelector implements SubstrateSelector {
  private rules: Array<{
    name: string;
    condition: (exp: Experience) => boolean;
    substrate: SubstrateType;
    priority: number;
  }> = [];

  constructor() {
    this.setupDefaultRules();
  }

  private setupDefaultRules(): void {
    // 规则1：简单问候 → Computation
    this.addRule({
      name: 'greeting',
      condition: (exp) => {
        const intent = this.getIntent(exp);
        return intent === 'greeting';
      },
      substrate: 'computation',
      priority: 100
    });

    // 规则2：格式转换 → Computation
    this.addRule({
      name: 'format-conversion',
      condition: (exp) => {
        const content = exp.content;
        return typeof content === 'object' && content.type === 'format';
      },
      substrate: 'computation',
      priority: 90
    });

    // 规则3：数学计算 → Computation
    this.addRule({
      name: 'math',
      condition: (exp) => {
        const text = this.getText(exp);
        return /^\d+\s*[+\-*/]\s*\d+$/.test(text);
      },
      substrate: 'computation',
      priority: 95
    });

    // 规则4：代码生成 → Generation
    this.addRule({
      name: 'code-generation',
      condition: (exp) => {
        const intent = this.getIntent(exp);
        const text = this.getText(exp);
        return intent === 'code_related' || text.includes('写代码') || text.includes('实现');
      },
      substrate: 'generation',
      priority: 80
    });

    // 规则5：复杂问题 → Generation
    this.addRule({
      name: 'complex-question',
      condition: (exp) => {
        const complexity = this.getComplexity(exp);
        return complexity === 'complex';
      },
      substrate: 'generation',
      priority: 70
    });

    // 规则6：需要创造力 → Generation
    this.addRule({
      name: 'creative',
      condition: (exp) => {
        const text = this.getText(exp);
        return /写|创作|设计|想象|创意/.test(text);
      },
      substrate: 'generation',
      priority: 75
    });

    // 默认规则：Generation
    this.addRule({
      name: 'default',
      condition: () => true,
      substrate: 'generation',
      priority: 0
    });
  }

  addRule(rule: {
    name: string;
    condition: (exp: Experience) => boolean;
    substrate: SubstrateType;
    priority: number;
  }): void {
    this.rules.push(rule);
    this.rules.sort((a, b) => b.priority - a.priority);
  }

  select(experience: Experience): SubstrateType {
    for (const rule of this.rules) {
      if (rule.condition(experience)) {
        return rule.substrate;
      }
    }
    return 'generation';
  }

  explain(experience: Experience): string {
    for (const rule of this.rules) {
      if (rule.condition(experience)) {
        return `选择 ${rule.substrate}，原因：匹配规则 "${rule.name}"`;
      }
    }
    return '使用默认选择：generation';
  }

  private getIntent(exp: Experience): string | null {
    return exp.content?.perceptionData?.intent ||
           exp.content?.intent ||
           null;
  }

  private getComplexity(exp: Experience): string | null {
    return exp.content?.perceptionData?.complexity ||
           exp.content?.complexity ||
           null;
  }

  private getText(exp: Experience): string {
    if (typeof exp.content === 'string') return exp.content;
    return exp.content?.raw ||
           exp.content?.sensoryData?.raw ||
           JSON.stringify(exp.content);
  }
}
```

### 基于成本的选择器

```typescript
// cost-based-selector.ts
export class CostBasedSelector implements SubstrateSelector {
  private computation: ComputationEngine;
  private generation: GenerationEngine;
  private costThreshold: number;

  constructor(
    computation: ComputationEngine,
    generation: GenerationEngine,
    costThreshold: number = 100  // 毫秒
  ) {
    this.computation = computation;
    this.generation = generation;
    this.costThreshold = costThreshold;
  }

  select(experience: Experience): SubstrateType {
    // 如果计算基质能处理，优先使用
    if (this.computation.canHandle(experience.content)) {
      const cost = this.computation.estimateCost(experience.content);
      if (cost.time < this.costThreshold) {
        return 'computation';
      }
    }

    // 否则使用生成基质
    return 'generation';
  }

  explain(experience: Experience): string {
    if (this.computation.canHandle(experience.content)) {
      const cost = this.computation.estimateCost(experience.content);
      if (cost.time < this.costThreshold) {
        return `选择 computation：预估耗时 ${cost.time}ms < 阈值 ${this.costThreshold}ms`;
      }
      return `选择 generation：computation 预估耗时 ${cost.time}ms 超过阈值`;
    }
    return '选择 generation：computation 无法处理此输入';
  }
}
```

### 混合选择器

```typescript
// hybrid-selector.ts
export class HybridSelector implements SubstrateSelector {
  private ruleSelector: RuleBasedSelector;
  private costSelector: CostBasedSelector;
  private weights = { rule: 0.6, cost: 0.4 };

  constructor(computation: ComputationEngine, generation: GenerationEngine) {
    this.ruleSelector = new RuleBasedSelector();
    this.costSelector = new CostBasedSelector(computation, generation);
  }

  select(experience: Experience): SubstrateType {
    const ruleChoice = this.ruleSelector.select(experience);
    const costChoice = this.costSelector.select(experience);

    // 如果两者一致，直接返回
    if (ruleChoice === costChoice) {
      return ruleChoice;
    }

    // 规则选择 computation 优先级更高
    if (ruleChoice === 'computation') {
      return 'computation';
    }

    // 成本选择 computation 也考虑
    if (costChoice === 'computation') {
      return 'computation';
    }

    return 'generation';
  }

  explain(experience: Experience): string {
    const ruleExplain = this.ruleSelector.explain(experience);
    const costExplain = this.costSelector.explain(experience);
    const final = this.select(experience);

    return `
最终选择: ${final}
规则分析: ${ruleExplain}
成本分析: ${costExplain}
`.trim();
  }
}
```

---

## 9.4.4 基质管理器

### SubstrateManager

```typescript
// substrate-manager.ts
export class SubstrateManager {
  private computation: ComputationEngine;
  private generation: GenerationEngine;
  private selector: SubstrateSelector;
  private stats = {
    computation: { calls: 0, totalTime: 0 },
    generation: { calls: 0, totalTime: 0, tokens: 0 }
  };

  constructor(config: {
    apiKey: string;
    model?: string;
    selector?: SubstrateSelector;
  }) {
    this.computation = new ComputationEngine();
    setupDefaultHandlers(this.computation);

    this.generation = new GenerationEngine({
      apiKey: config.apiKey,
      model: config.model
    });

    this.selector = config.selector ||
      new HybridSelector(this.computation, this.generation);
  }

  async process<T, U>(experience: Experience<T>): Promise<{
    result: U;
    substrate: SubstrateType;
    duration: number;
  }> {
    const substrate = this.selector.select(experience);
    const startTime = Date.now();

    let result: U;

    if (substrate === 'computation') {
      result = await this.computation.process(experience.content);
      this.stats.computation.calls++;
      this.stats.computation.totalTime += Date.now() - startTime;
    } else {
      result = await this.generation.process(experience.content);
      this.stats.generation.calls++;
      this.stats.generation.totalTime += Date.now() - startTime;
    }

    return {
      result,
      substrate,
      duration: Date.now() - startTime
    };
  }

  explainSelection(experience: Experience): string {
    return this.selector.explain(experience);
  }

  getStats(): typeof this.stats {
    return { ...this.stats };
  }

  getEfficiencyReport(): string {
    const { computation, generation } = this.stats;
    const totalCalls = computation.calls + generation.calls;

    if (totalCalls === 0) return '暂无处理记录';

    const computationRatio = (computation.calls / totalCalls * 100).toFixed(1);
    const avgComputationTime = computation.calls > 0
      ? (computation.totalTime / computation.calls).toFixed(1)
      : 'N/A';
    const avgGenerationTime = generation.calls > 0
      ? (generation.totalTime / generation.calls).toFixed(1)
      : 'N/A';

    return `
=== 基质效率报告 ===
总处理次数: ${totalCalls}

Computation:
  - 调用次数: ${computation.calls} (${computationRatio}%)
  - 平均耗时: ${avgComputationTime}ms

Generation:
  - 调用次数: ${generation.calls} (${100 - parseFloat(computationRatio)}%)
  - 平均耗时: ${avgGenerationTime}ms
`.trim();
  }
}
```

---

## 9.4.5 实战示例

### 完整使用示例

```typescript
// example.ts
async function main() {
  const manager = new SubstrateManager({
    apiKey: process.env.ANTHROPIC_API_KEY!
  });

  const testCases = [
    '你好',                           // → computation (greeting)
    '1 + 2 * 3',                      // → computation (math)
    '现在几点了',                      // → computation (time)
    '帮我写一个 React 组件',           // → generation (code)
    '解释一下量子计算的原理',          // → generation (complex)
    '设计一个用户登录流程',            // → generation (creative)
  ];

  for (const input of testCases) {
    const exp = createExperience(input, { source: 'user' });

    console.log(`\n输入: "${input}"`);
    console.log(manager.explainSelection(exp));

    const { result, substrate, duration } = await manager.process(exp);
    console.log(`结果: ${JSON.stringify(result).slice(0, 100)}...`);
    console.log(`基质: ${substrate}, 耗时: ${duration}ms`);
  }

  console.log('\n' + manager.getEfficiencyReport());
}

main();
```

### 输出示例

```
输入: "你好"
选择 computation，原因：匹配规则 "greeting"
结果: {"response":"你好！有什么可以帮你的吗？","type":"greeting"}
基质: computation, 耗时: 2ms

输入: "1 + 2 * 3"
选择 computation，原因：匹配规则 "math"
结果: {"result":7,"success":true}
基质: computation, 耗时: 1ms

输入: "帮我写一个 React 组件"
选择 generation，原因：匹配规则 "code-generation"
结果: "以下是一个简单的 React 组件示例：\n\n```tsx\nimport React from '...
基质: generation, 耗时: 2345ms

=== 基质效率报告 ===
总处理次数: 6

Computation:
  - 调用次数: 3 (50.0%)
  - 平均耗时: 1.3ms

Generation:
  - 调用次数: 3 (50.0%)
  - 平均耗时: 2100.0ms
```

---

## 本节要点

1. **双基质理念**：Computation（快速、确定）vs Generation（灵活、创造）
2. **接口设计**：统一的 Substrate 接口，支持多种实现
3. **选择策略**：规则驱动、成本驱动、混合策略
4. **成本意识**：优先使用低成本的 Computation
5. **效率监控**：跟踪各基质的使用情况

---

## 下一步

掌握了双基质策略后，下一节我们将学习如何将 Monogent 与 AgentX/PromptX 完整集成。

---

[上一节：七阶段管道实现](9.3-七阶段管道实现.md) | [下一节：与 AgentX/PromptX 集成](9.5-与AgentX-PromptX集成.md)
