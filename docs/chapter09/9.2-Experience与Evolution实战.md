# 9.2 Experience 与 Evolution 实战

> 认知的原子单位与演化机制

本节将深入实现 Experience 数据结构和演化机制，这是 Monogent 认知系统的核心基础。

---

## 9.2.1 Experience 数据结构

### 完整定义

```typescript
// experience.ts
import { v4 as uuid } from 'uuid';

// 处理阶段枚举
export enum Stage {
  SENSATION = 'sensation',
  PERCEPTION = 'perception',
  REPRESENTATION = 'representation',
  ACTIVATION = 'activation',
  ASSOCIATION = 'association',
  RECOLLECTION = 'recollection',
  INTEGRATION = 'integration'
}

// 基质类型
export type Substrate = 'computation' | 'generation';

// 体验来源
export type Source = 'user' | 'system' | 'derived' | 'memory';

// 元数据
export interface ExperienceMetadata {
  timestamp: number;
  source: Source;
  stage: Stage;
  duration?: number;      // 处理耗时
  substrate?: Substrate;  // 使用的基质
  tags?: string[];        // 标签
}

// Experience 核心接口
export interface Experience<T = any> {
  readonly id: string;
  readonly content: T;
  readonly metadata: ExperienceMetadata;
  readonly prev?: Experience;
  next?: Experience;
}

// 创建 Experience
export function createExperience<T>(
  content: T,
  options: {
    source?: Source;
    stage?: Stage;
    prev?: Experience;
    tags?: string[];
  } = {}
): Experience<T> {
  const experience: Experience<T> = {
    id: uuid(),
    content,
    metadata: {
      timestamp: Date.now(),
      source: options.source || 'system',
      stage: options.stage || Stage.SENSATION,
      tags: options.tags
    },
    prev: options.prev
  };

  // 链接到前一个体验
  if (options.prev) {
    options.prev.next = experience;
  }

  return experience;
}
```

### 使用示例

```typescript
// 创建用户输入体验
const userExp = createExperience('帮我写一个 React 组件', {
  source: 'user',
  stage: Stage.SENSATION
});

console.log(userExp);
// {
//   id: 'exp_abc123',
//   content: '帮我写一个 React 组件',
//   metadata: {
//     timestamp: 1703001234567,
//     source: 'user',
//     stage: 'sensation'
//   }
// }

// 创建派生体验（链接到前一个）
const parsedExp = createExperience(
  { intent: 'code_generation', tech: 'React', type: 'component' },
  { source: 'derived', stage: Stage.PERCEPTION, prev: userExp }
);

// 现在 userExp.next === parsedExp
// 并且 parsedExp.prev === userExp
```

---

## 9.2.2 体验链（Experience Chain）

### ExperienceChain 实现

```typescript
// experience-chain.ts
export class ExperienceChain {
  private head: Experience | null = null;
  private tail: Experience | null = null;
  private _length: number = 0;

  // 添加新体验
  append<T>(content: T, options: Partial<ExperienceMetadata> = {}): Experience<T> {
    const exp = createExperience(content, {
      ...options,
      prev: this.tail || undefined
    });

    if (!this.head) {
      this.head = exp;
    }
    this.tail = exp;
    this._length++;

    return exp;
  }

  // 获取链长度
  get length(): number {
    return this._length;
  }

  // 获取头部
  getHead(): Experience | null {
    return this.head;
  }

  // 获取尾部
  getTail(): Experience | null {
    return this.tail;
  }

  // 转为数组
  toArray(): Experience[] {
    const result: Experience[] = [];
    let current = this.head;

    while (current) {
      result.push(current);
      current = current.next;
    }

    return result;
  }

  // 按阶段过滤
  filterByStage(stage: Stage): Experience[] {
    return this.toArray().filter(exp => exp.metadata.stage === stage);
  }

  // 按来源过滤
  filterBySource(source: Source): Experience[] {
    return this.toArray().filter(exp => exp.metadata.source === source);
  }

  // 获取处理时间线
  getTimeline(): Array<{ stage: Stage; duration: number }> {
    const experiences = this.toArray();
    const timeline: Array<{ stage: Stage; duration: number }> = [];

    for (let i = 1; i < experiences.length; i++) {
      const prev = experiences[i - 1];
      const curr = experiences[i];
      timeline.push({
        stage: curr.metadata.stage,
        duration: curr.metadata.timestamp - prev.metadata.timestamp
      });
    }

    return timeline;
  }

  // 可视化输出
  visualize(): string {
    const experiences = this.toArray();
    const lines: string[] = [];

    experiences.forEach((exp, index) => {
      const prefix = index === 0 ? '┌' : index === experiences.length - 1 ? '└' : '├';
      const stage = exp.metadata.stage.padEnd(15);
      const source = `[${exp.metadata.source}]`.padEnd(10);
      const content = typeof exp.content === 'string'
        ? exp.content.slice(0, 30)
        : JSON.stringify(exp.content).slice(0, 30);

      lines.push(`${prefix}─ ${stage} ${source} ${content}...`);
    });

    return lines.join('\n');
  }
}
```

### 使用示例

```typescript
const chain = new ExperienceChain();

// 模拟认知过程
chain.append('帮我写代码', { source: 'user', stage: Stage.SENSATION });
chain.append({ intent: 'code', lang: 'ts' }, { source: 'derived', stage: Stage.PERCEPTION });
chain.append({ embedding: [0.1, 0.2, ...] }, { source: 'derived', stage: Stage.REPRESENTATION });
chain.append({ cues: ['TypeScript', '代码'] }, { source: 'system', stage: Stage.ACTIVATION });
chain.append({ memories: [...] }, { source: 'memory', stage: Stage.RECOLLECTION });
chain.append('这是生成的代码...', { source: 'system', stage: Stage.INTEGRATION });

console.log(chain.visualize());
// ┌─ sensation       [user]     帮我写代码...
// ├─ perception      [derived]  {"intent":"code","lang":"ts...
// ├─ representation  [derived]  {"embedding":[0.1,0.2,...
// ├─ activation      [system]   {"cues":["TypeScript","代码...
// ├─ recollection    [memory]   {"memories":[...
// └─ integration     [system]   这是生成的代码...

console.log('处理时间线:', chain.getTimeline());
```

---

## 9.2.3 微演化（Micro Evolution）

微演化是在**同一个 Experience 内部**进行内容变换，身份保持不变。

### 实现

```typescript
// evolution.ts

// 微演化：变换内容，保持身份
export function microEvolve<T, U>(
  experience: Experience<T>,
  transform: (content: T) => U,
  newStage?: Stage
): Experience<U> {
  const evolved: Experience<U> = {
    id: experience.id,  // 保持相同 ID
    content: transform(experience.content),
    metadata: {
      ...experience.metadata,
      stage: newStage || nextStage(experience.metadata.stage),
      timestamp: Date.now()
    },
    prev: experience.prev
  };

  // 更新链接
  if (experience.prev) {
    experience.prev.next = evolved;
  }
  if (experience.next) {
    evolved.next = experience.next;
    experience.next.prev = evolved;
  }

  return evolved;
}

// 获取下一个阶段
function nextStage(current: Stage): Stage {
  const order = [
    Stage.SENSATION,
    Stage.PERCEPTION,
    Stage.REPRESENTATION,
    Stage.ACTIVATION,
    Stage.ASSOCIATION,
    Stage.RECOLLECTION,
    Stage.INTEGRATION
  ];

  const index = order.indexOf(current);
  return index < order.length - 1 ? order[index + 1] : current;
}
```

### 微演化示例

```typescript
// 原始体验：用户输入
let exp = createExperience('帮我优化这段代码', {
  source: 'user',
  stage: Stage.SENSATION
});

// 微演化1：提取特征
exp = microEvolve(exp, (text) => ({
  raw: text,
  tokens: text.split(/\s+/),
  length: text.length
}), Stage.PERCEPTION);

// 微演化2：识别意图
exp = microEvolve(exp, (data) => ({
  ...data,
  intent: 'code_optimization',
  confidence: 0.95
}));

// 微演化3：语义编码
exp = microEvolve(exp, (data) => ({
  ...data,
  embedding: computeEmbedding(data.raw),
  keywords: extractKeywords(data.raw)
}), Stage.REPRESENTATION);

console.log(exp.id);  // 仍然是原来的 ID
console.log(exp.metadata.stage);  // 'representation'
console.log(exp.content);
// {
//   raw: '帮我优化这段代码',
//   tokens: ['帮我', '优化', '这段', '代码'],
//   length: 8,
//   intent: 'code_optimization',
//   confidence: 0.95,
//   embedding: [0.1, 0.2, ...],
//   keywords: ['优化', '代码']
// }
```

---

## 9.2.4 宏演化（Macro Evolution）

宏演化是创建**新的 Experience**，形成链式结构。

### 实现

```typescript
// 宏演化：创建新体验，链接到当前体验
export function macroEvolve<T, U>(
  experience: Experience<T>,
  newContent: U,
  options: {
    stage?: Stage;
    source?: Source;
    tags?: string[];
  } = {}
): Experience<U> {
  const newExp: Experience<U> = {
    id: uuid(),  // 新的 ID
    content: newContent,
    metadata: {
      timestamp: Date.now(),
      source: options.source || 'derived',
      stage: options.stage || nextStage(experience.metadata.stage),
      tags: options.tags
    },
    prev: experience
  };

  // 链接
  experience.next = newExp;

  return newExp;
}

// 批量宏演化
export function macroEvolveBatch<T>(
  experience: Experience,
  contents: T[],
  options: {
    stage?: Stage;
    source?: Source;
  } = {}
): Experience<T>[] {
  let current = experience;
  const results: Experience<T>[] = [];

  for (const content of contents) {
    const newExp = macroEvolve(current, content, options);
    results.push(newExp);
    current = newExp;
  }

  return results;
}
```

### 宏演化示例

```typescript
// 用户输入
const userExp = createExperience('React 性能优化有哪些方法？', {
  source: 'user',
  stage: Stage.SENSATION
});

// 宏演化：理解阶段产生新体验
const understandingExp = macroEvolve(userExp, {
  topic: 'React 性能优化',
  questionType: 'how-to',
  techStack: ['React']
}, { stage: Stage.PERCEPTION });

// 宏演化：召回记忆
const memoryExp = macroEvolve(understandingExp, {
  memories: [
    { content: 'useMemo 用于缓存计算结果', strength: 0.8 },
    { content: 'useCallback 用于缓存函数', strength: 0.7 },
    { content: 'React.memo 用于组件缓存', strength: 0.9 }
  ]
}, { stage: Stage.RECOLLECTION, source: 'memory' });

// 宏演化：整合生成回复
const responseExp = macroEvolve(memoryExp, {
  response: `React 性能优化的常用方法包括：
1. useMemo：缓存计算结果
2. useCallback：缓存函数引用
3. React.memo：缓存组件渲染
...`,
  sources: memoryExp.content.memories
}, { stage: Stage.INTEGRATION });

// 现在形成了完整的体验链
// userExp → understandingExp → memoryExp → responseExp
```

---

## 9.2.5 演化工具函数

### 常用演化操作

```typescript
// evolution-utils.ts

// 映射演化：对内容应用函数
export function mapEvolve<T, U>(
  exp: Experience<T>,
  fn: (content: T) => U
): Experience<U> {
  return microEvolve(exp, fn);
}

// 过滤演化：根据条件决定是否演化
export function filterEvolve<T>(
  exp: Experience<T>,
  predicate: (content: T) => boolean,
  ifTrue: (content: T) => T,
  ifFalse?: (content: T) => T
): Experience<T> {
  if (predicate(exp.content)) {
    return microEvolve(exp, ifTrue);
  } else if (ifFalse) {
    return microEvolve(exp, ifFalse);
  }
  return exp;
}

// 合并演化：合并多个体验
export function mergeEvolve<T extends object>(
  primary: Experience<T>,
  ...others: Experience<Partial<T>>[]
): Experience<T> {
  const merged = others.reduce(
    (acc, exp) => ({ ...acc, ...exp.content }),
    primary.content
  );
  return microEvolve(primary, () => merged);
}

// 分支演化：一个体验演化为多个
export function branchEvolve<T, U>(
  exp: Experience<T>,
  branches: Array<{
    name: string;
    transform: (content: T) => U;
    stage?: Stage;
  }>
): Map<string, Experience<U>> {
  const results = new Map<string, Experience<U>>();

  for (const branch of branches) {
    const branchExp = macroEvolve(exp, branch.transform(exp.content), {
      stage: branch.stage,
      tags: [branch.name]
    });
    results.set(branch.name, branchExp);
  }

  return results;
}

// 条件演化：根据条件选择不同演化路径
export function conditionalEvolve<T, U, V>(
  exp: Experience<T>,
  condition: (content: T) => boolean,
  ifBranch: (content: T) => U,
  elseBranch: (content: T) => V
): Experience<U | V> {
  if (condition(exp.content)) {
    return macroEvolve(exp, ifBranch(exp.content));
  } else {
    return macroEvolve(exp, elseBranch(exp.content));
  }
}
```

### 实战示例

```typescript
// 场景：处理用户输入，根据类型选择不同处理路径

const input = createExperience('你好', { source: 'user' });

// 分支演化：同时尝试多种理解方式
const branches = branchEvolve(input, [
  {
    name: 'greeting',
    transform: (text) => ({ type: 'greeting', response: '你好！有什么可以帮你？' })
  },
  {
    name: 'question',
    transform: (text) => ({ type: 'question', needsProcessing: true })
  },
  {
    name: 'command',
    transform: (text) => ({ type: 'command', action: null })
  }
]);

// 根据置信度选择最佳分支
const greeting = branches.get('greeting')!;
const question = branches.get('question')!;

// 条件演化：简单问候直接回复，否则继续处理
const finalExp = conditionalEvolve(
  input,
  (text) => isGreeting(text),
  (text) => ({ response: '你好！有什么可以帮你？', direct: true }),
  (text) => ({ needsFurtherProcessing: true, originalText: text })
);
```

---

## 9.2.6 体验追踪与调试

### ExperienceTracer

```typescript
// experience-tracer.ts
export class ExperienceTracer {
  private logs: Array<{
    timestamp: number;
    type: 'create' | 'micro' | 'macro';
    experienceId: string;
    stage: Stage;
    contentPreview: string;
  }> = [];

  // 记录创建
  logCreate(exp: Experience): void {
    this.logs.push({
      timestamp: Date.now(),
      type: 'create',
      experienceId: exp.id,
      stage: exp.metadata.stage,
      contentPreview: this.preview(exp.content)
    });
  }

  // 记录微演化
  logMicroEvolve(before: Experience, after: Experience): void {
    this.logs.push({
      timestamp: Date.now(),
      type: 'micro',
      experienceId: after.id,
      stage: after.metadata.stage,
      contentPreview: `${this.preview(before.content)} → ${this.preview(after.content)}`
    });
  }

  // 记录宏演化
  logMacroEvolve(parent: Experience, child: Experience): void {
    this.logs.push({
      timestamp: Date.now(),
      type: 'macro',
      experienceId: child.id,
      stage: child.metadata.stage,
      contentPreview: this.preview(child.content)
    });
  }

  // 获取追踪报告
  getReport(): string {
    const lines = ['=== Experience Trace Report ===', ''];

    for (const log of this.logs) {
      const time = new Date(log.timestamp).toISOString().slice(11, 23);
      const type = log.type.padEnd(6);
      const stage = log.stage.padEnd(15);
      lines.push(`[${time}] ${type} | ${stage} | ${log.contentPreview}`);
    }

    lines.push('', `Total: ${this.logs.length} operations`);
    return lines.join('\n');
  }

  private preview(content: any): string {
    const str = typeof content === 'string' ? content : JSON.stringify(content);
    return str.length > 40 ? str.slice(0, 40) + '...' : str;
  }
}

// 全局追踪器
export const globalTracer = new ExperienceTracer();
```

### 使用追踪器

```typescript
const tracer = new ExperienceTracer();

// 创建
const exp1 = createExperience('用户输入', { source: 'user' });
tracer.logCreate(exp1);

// 微演化
const exp2 = microEvolve(exp1, (c) => ({ text: c, parsed: true }));
tracer.logMicroEvolve(exp1, exp2);

// 宏演化
const exp3 = macroEvolve(exp2, { response: '回复内容' });
tracer.logMacroEvolve(exp2, exp3);

console.log(tracer.getReport());
// === Experience Trace Report ===
//
// [10:30:45.123] create | sensation       | 用户输入
// [10:30:45.125] micro  | perception      | 用户输入 → {"text":"用户输入","parsed":...
// [10:30:45.130] macro  | representation  | {"response":"回复内容"}
//
// Total: 3 operations
```

---

## 本节要点

1. **Experience 结构**：id、content、metadata、prev/next 链接
2. **ExperienceChain**：管理体验的链式结构
3. **微演化**：内容变换，ID 不变（同一体验的内部变化）
4. **宏演化**：创建新体验，形成链（认知过程的推进）
5. **演化工具**：map、filter、merge、branch、conditional
6. **追踪调试**：ExperienceTracer 记录演化过程

---

## 下一步

掌握了 Experience 和 Evolution 后，下一节我们将实现完整的七阶段认知管道。

---

[上一节：Monogent 架构深入](9.1-Monogent架构深入.md) | [下一节：七阶段管道实现](9.3-七阶段管道实现.md)
