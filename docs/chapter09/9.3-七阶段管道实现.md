# 9.3 七阶段管道实现

> 从感觉到整合的完整认知流程

本节将实现 Monogent 的七阶段认知管道，这是将原始输入转化为有意义输出的核心处理流程。

---

## 9.3.1 管道架构

### 七阶段概览

```
输入
  │
  ▼
┌─────────────┐
│  Sensation  │ ← 感觉：接收原始输入
└──────┬──────┘
       ▼
┌─────────────┐
│ Perception  │ ← 知觉：特征检测与识别
└──────┬──────┘
       ▼
┌──────────────────┐
│ Representation   │ ← 表征：语义编码
└────────┬─────────┘
         ▼
┌─────────────┐
│ Activation  │ ← 激活：激活相关记忆节点
└──────┬──────┘
       ▼
┌─────────────┐
│ Association │ ← 联想：扩散激活
└──────┬──────┘
       ▼
┌──────────────┐
│ Recollection │ ← 回忆：召回记忆
└───────┬──────┘
        ▼
┌─────────────┐
│ Integration │ ← 整合：生成输出
└──────┬──────┘
       ▼
     输出
```

### 阶段接口定义

```typescript
// pipeline.ts
import { Experience, Stage, createExperience, macroEvolve } from './experience';

// 阶段处理器接口
export interface StageProcessor<TInput = any, TOutput = any> {
  readonly stage: Stage;
  process(input: Experience<TInput>): Promise<Experience<TOutput>>;
}

// 管道配置
export interface PipelineConfig {
  stages: Stage[];
  processors: Map<Stage, StageProcessor>;
  substrate: SubstrateSelector;
  memory: MemoryInterface;
  onStageStart?: (stage: Stage, exp: Experience) => void;
  onStageEnd?: (stage: Stage, exp: Experience) => void;
}

// 认知管道
export class CognitivePipeline {
  private config: PipelineConfig;
  private chain: ExperienceChain;

  constructor(config: PipelineConfig) {
    this.config = config;
    this.chain = new ExperienceChain();
  }

  async process(input: any): Promise<Experience> {
    // 创建初始体验
    let exp = this.chain.append(input, {
      source: 'user',
      stage: Stage.SENSATION
    });

    // 依次执行各阶段
    for (const stage of this.config.stages) {
      const processor = this.config.processors.get(stage);
      if (!processor) continue;

      this.config.onStageStart?.(stage, exp);
      exp = await processor.process(exp);
      this.config.onStageEnd?.(stage, exp);
    }

    return exp;
  }

  getChain(): ExperienceChain {
    return this.chain;
  }
}
```

---

## 9.3.2 Sensation（感觉）

感觉阶段负责接收和标准化原始输入。

```typescript
// stages/sensation.ts
export class SensationProcessor implements StageProcessor {
  readonly stage = Stage.SENSATION;

  async process(input: Experience): Promise<Experience> {
    const content = input.content;

    // 标准化输入
    const sensoryData = {
      raw: content,
      type: this.detectType(content),
      encoding: this.detectEncoding(content),
      timestamp: Date.now(),
      metadata: {
        length: typeof content === 'string' ? content.length : null,
        format: this.detectFormat(content)
      }
    };

    return macroEvolve(input, sensoryData, { stage: Stage.SENSATION });
  }

  private detectType(content: any): string {
    if (typeof content === 'string') return 'text';
    if (Array.isArray(content)) return 'array';
    if (typeof content === 'object') return 'object';
    return 'unknown';
  }

  private detectEncoding(content: any): string {
    if (typeof content === 'string') {
      // 检测是否包含中文
      if (/[\u4e00-\u9fa5]/.test(content)) return 'utf8-zh';
      return 'utf8-en';
    }
    return 'binary';
  }

  private detectFormat(content: any): string {
    if (typeof content !== 'string') return 'structured';
    if (content.startsWith('{') || content.startsWith('[')) return 'json';
    if (content.includes('\n')) return 'multiline';
    return 'plain';
  }
}
```

---

## 9.3.3 Perception（知觉）

知觉阶段负责特征检测和意图识别。

```typescript
// stages/perception.ts
export class PerceptionProcessor implements StageProcessor {
  readonly stage = Stage.PERCEPTION;

  private patterns = {
    question: /[？?]|怎么|如何|什么|为什么|是否/,
    command: /^(请|帮我|给我|执行|运行)/,
    greeting: /^(你好|hi|hello|嗨)/i,
    code: /```|function|const |let |var |class |import /
  };

  async process(input: Experience): Promise<Experience> {
    const raw = input.content.raw || input.content;
    const text = typeof raw === 'string' ? raw : JSON.stringify(raw);

    const perception = {
      // 意图识别
      intent: this.detectIntent(text),
      intentConfidence: 0,

      // 实体提取
      entities: this.extractEntities(text),

      // 情感分析
      sentiment: this.analyzeSentiment(text),

      // 复杂度评估
      complexity: this.assessComplexity(text),

      // 原始数据保留
      sensoryData: input.content
    };

    // 计算置信度
    perception.intentConfidence = this.calculateConfidence(text, perception.intent);

    return macroEvolve(input, perception, { stage: Stage.PERCEPTION });
  }

  private detectIntent(text: string): string {
    if (this.patterns.greeting.test(text)) return 'greeting';
    if (this.patterns.question.test(text)) return 'question';
    if (this.patterns.command.test(text)) return 'command';
    if (this.patterns.code.test(text)) return 'code_related';
    return 'statement';
  }

  private extractEntities(text: string): Array<{ type: string; value: string }> {
    const entities: Array<{ type: string; value: string }> = [];

    // 提取技术术语
    const techTerms = text.match(/React|Vue|TypeScript|JavaScript|Python|Node\.js/gi);
    if (techTerms) {
      techTerms.forEach(term => entities.push({ type: 'technology', value: term }));
    }

    // 提取数字
    const numbers = text.match(/\d+/g);
    if (numbers) {
      numbers.forEach(num => entities.push({ type: 'number', value: num }));
    }

    return entities;
  }

  private analyzeSentiment(text: string): { polarity: number; subjectivity: number } {
    // 简化的情感分析
    const positiveWords = ['好', '棒', '优秀', '感谢', 'great', 'good', 'thanks'];
    const negativeWords = ['差', '糟糕', '问题', '错误', 'bad', 'error', 'bug'];

    let score = 0;
    positiveWords.forEach(w => { if (text.includes(w)) score += 1; });
    negativeWords.forEach(w => { if (text.includes(w)) score -= 1; });

    return {
      polarity: Math.max(-1, Math.min(1, score / 3)),
      subjectivity: 0.5
    };
  }

  private assessComplexity(text: string): 'simple' | 'medium' | 'complex' {
    const length = text.length;
    const sentences = text.split(/[。.!?！？]/).length;

    if (length < 20 && sentences <= 1) return 'simple';
    if (length < 100 && sentences <= 3) return 'medium';
    return 'complex';
  }

  private calculateConfidence(text: string, intent: string): number {
    const pattern = this.patterns[intent as keyof typeof this.patterns];
    if (!pattern) return 0.5;

    const matches = text.match(pattern);
    return matches ? 0.8 + (matches.length * 0.05) : 0.5;
  }
}
```

---

## 9.3.4 Representation（表征）

表征阶段负责语义编码，将输入转化为内部表示。

```typescript
// stages/representation.ts
export class RepresentationProcessor implements StageProcessor {
  readonly stage = Stage.REPRESENTATION;

  async process(input: Experience): Promise<Experience> {
    const perception = input.content;

    const representation = {
      // 关键词提取
      keywords: this.extractKeywords(perception),

      // 语义向量（简化版，实际应使用嵌入模型）
      semanticVector: this.computeSemanticVector(perception),

      // 结构化表示
      structure: {
        intent: perception.intent,
        entities: perception.entities,
        complexity: perception.complexity
      },

      // 查询构建（用于记忆检索）
      queryHints: this.buildQueryHints(perception),

      // 保留上层数据
      perceptionData: perception
    };

    return macroEvolve(input, representation, { stage: Stage.REPRESENTATION });
  }

  private extractKeywords(perception: any): string[] {
    const keywords: string[] = [];

    // 从实体中提取
    if (perception.entities) {
      perception.entities.forEach((e: any) => keywords.push(e.value));
    }

    // 从原始文本中提取（简化版）
    const text = perception.sensoryData?.raw || '';
    const words = text.split(/\s+/).filter((w: string) => w.length > 2);
    keywords.push(...words.slice(0, 5));

    return [...new Set(keywords)];
  }

  private computeSemanticVector(perception: any): number[] {
    // 简化版：实际应使用嵌入模型
    // 这里返回一个基于内容的伪向量
    const text = perception.sensoryData?.raw || '';
    const hash = this.simpleHash(text);

    return Array(8).fill(0).map((_, i) =>
      Math.sin(hash * (i + 1)) * 0.5 + 0.5
    );
  }

  private simpleHash(str: string): number {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      hash = ((hash << 5) - hash) + str.charCodeAt(i);
      hash = hash & hash;
    }
    return hash;
  }

  private buildQueryHints(perception: any): string[] {
    const hints: string[] = [];

    // 基于意图的提示
    if (perception.intent === 'question') {
      hints.push('知识', '解答', '方法');
    } else if (perception.intent === 'code_related') {
      hints.push('代码', '实现', '示例');
    }

    // 添加实体作为提示
    perception.entities?.forEach((e: any) => hints.push(e.value));

    return hints;
  }
}
```

---

## 9.3.5 Activation（激活）

激活阶段负责激活记忆网络中的相关节点。

```typescript
// stages/activation.ts
export class ActivationProcessor implements StageProcessor {
  readonly stage = Stage.ACTIVATION;
  private memory: MemoryInterface;

  constructor(memory: MemoryInterface) {
    this.memory = memory;
  }

  async process(input: Experience): Promise<Experience> {
    const representation = input.content;

    // 构建激活查询
    const query = representation.keywords.join(' ');

    // 从记忆中获取初始激活
    const initialCues = await this.memory.recall({
      query,
      mode: 'focused',
      limit: 10
    });

    const activation = {
      // 激活的线索
      activatedCues: initialCues.map(cue => ({
        keyword: cue.keyword,
        strength: cue.weight,
        source: cue.source
      })),

      // 激活强度分布
      activationMap: this.buildActivationMap(initialCues),

      // 激活阈值
      threshold: 0.3,

      // 保留上层数据
      representationData: representation
    };

    return macroEvolve(input, activation, {
      stage: Stage.ACTIVATION,
      source: 'memory'
    });
  }

  private buildActivationMap(cues: any[]): Map<string, number> {
    const map = new Map<string, number>();

    cues.forEach(cue => {
      map.set(cue.keyword, cue.weight);
    });

    return map;
  }
}
```

---

## 9.3.6 Association（联想）

联想阶段负责扩散激活，建立更广泛的关联。

```typescript
// stages/association.ts
export class AssociationProcessor implements StageProcessor {
  readonly stage = Stage.ASSOCIATION;
  private memory: MemoryInterface;

  constructor(memory: MemoryInterface) {
    this.memory = memory;
  }

  async process(input: Experience): Promise<Experience> {
    const activation = input.content;

    // 获取激活的线索
    const activatedCues = activation.activatedCues;

    // 扩散激活
    const associations: any[] = [];
    for (const cue of activatedCues) {
      if (cue.strength < activation.threshold) continue;

      // 从每个激活节点扩散
      const related = await this.memory.recall({
        query: cue.keyword,
        mode: 'creative',
        limit: 5
      });

      associations.push({
        source: cue.keyword,
        targets: related.map(r => ({
          keyword: r.keyword,
          strength: cue.strength * r.weight * 0.8,  // 衰减
          path: [cue.keyword, r.keyword]
        }))
      });
    }

    const association = {
      // 所有关联
      associations,

      // 合并后的关联图
      associationGraph: this.buildGraph(associations),

      // 最强关联路径
      strongestPaths: this.findStrongestPaths(associations),

      // 保留上层数据
      activationData: activation
    };

    return macroEvolve(input, association, { stage: Stage.ASSOCIATION });
  }

  private buildGraph(associations: any[]): Map<string, string[]> {
    const graph = new Map<string, string[]>();

    associations.forEach(assoc => {
      const targets = assoc.targets.map((t: any) => t.keyword);
      graph.set(assoc.source, targets);
    });

    return graph;
  }

  private findStrongestPaths(associations: any[]): any[] {
    const allPaths: any[] = [];

    associations.forEach(assoc => {
      assoc.targets.forEach((target: any) => {
        allPaths.push({
          path: target.path,
          strength: target.strength
        });
      });
    });

    return allPaths
      .sort((a, b) => b.strength - a.strength)
      .slice(0, 5);
  }
}
```

---

## 9.3.7 Recollection（回忆）

回忆阶段负责召回和排序记忆。

```typescript
// stages/recollection.ts
export class RecollectionProcessor implements StageProcessor {
  readonly stage = Stage.RECOLLECTION;
  private memory: MemoryInterface;

  constructor(memory: MemoryInterface) {
    this.memory = memory;
  }

  async process(input: Experience): Promise<Experience> {
    const association = input.content;

    // 收集所有相关关键词
    const allKeywords = new Set<string>();
    association.associations.forEach((assoc: any) => {
      allKeywords.add(assoc.source);
      assoc.targets.forEach((t: any) => allKeywords.add(t.keyword));
    });

    // 召回记忆
    const memories = await this.memory.recall({
      query: [...allKeywords].join(' '),
      mode: 'balanced',
      limit: 20
    });

    // 排序和筛选
    const rankedMemories = this.rankMemories(memories, association);

    const recollection = {
      // 召回的记忆
      memories: rankedMemories,

      // 记忆摘要
      summary: this.summarizeMemories(rankedMemories),

      // 记忆覆盖度
      coverage: this.calculateCoverage(rankedMemories, allKeywords),

      // 保留上层数据
      associationData: association
    };

    return macroEvolve(input, recollection, {
      stage: Stage.RECOLLECTION,
      source: 'memory'
    });
  }

  private rankMemories(memories: any[], association: any): any[] {
    // 根据与激活路径的匹配度排序
    const strongestPaths = association.strongestPaths || [];

    return memories.map(mem => {
      let pathScore = 0;
      strongestPaths.forEach((p: any) => {
        if (mem.content.includes(p.path[0]) || mem.content.includes(p.path[1])) {
          pathScore += p.strength;
        }
      });

      return {
        ...mem,
        relevanceScore: mem.weight * 0.6 + pathScore * 0.4
      };
    }).sort((a, b) => b.relevanceScore - a.relevanceScore);
  }

  private summarizeMemories(memories: any[]): string {
    const topMemories = memories.slice(0, 3);
    return topMemories.map(m => m.content).join('; ');
  }

  private calculateCoverage(memories: any[], keywords: Set<string>): number {
    const covered = new Set<string>();

    memories.forEach(mem => {
      keywords.forEach(kw => {
        if (mem.content.includes(kw)) covered.add(kw);
      });
    });

    return covered.size / keywords.size;
  }
}
```

---

## 9.3.8 Integration（整合）

整合阶段负责整合所有信息并生成最终输出。

```typescript
// stages/integration.ts
export class IntegrationProcessor implements StageProcessor {
  readonly stage = Stage.INTEGRATION;
  private generator: GenerationEngine;

  constructor(generator: GenerationEngine) {
    this.generator = generator;
  }

  async process(input: Experience): Promise<Experience> {
    const recollection = input.content;

    // 构建认知上下文
    const context = this.buildContext(recollection);

    // 决定是否需要生成
    const needsGeneration = this.assessGenerationNeed(recollection);

    let output: any;

    if (needsGeneration) {
      // 使用生成基质
      output = await this.generator.generate({
        prompt: this.buildPrompt(context),
        context: context.memories,
        parameters: {
          temperature: 0.7,
          maxTokens: 1000
        }
      });
    } else {
      // 使用计算基质（直接组合）
      output = this.computeResponse(context);
    }

    const integration = {
      // 最终输出
      output,

      // 使用的基质
      substrate: needsGeneration ? 'generation' : 'computation',

      // 认知上下文
      context,

      // 置信度
      confidence: this.calculateConfidence(recollection, output),

      // 完整认知链摘要
      cognitiveSummary: this.buildCognitiveSummary(recollection)
    };

    return macroEvolve(input, integration, { stage: Stage.INTEGRATION });
  }

  private buildContext(recollection: any): any {
    return {
      originalIntent: recollection.associationData?.activationData?.representationData?.perceptionData?.intent,
      keywords: recollection.associationData?.activationData?.representationData?.keywords || [],
      memories: recollection.memories?.slice(0, 5) || [],
      memorySummary: recollection.summary
    };
  }

  private assessGenerationNeed(recollection: any): boolean {
    const intent = recollection.associationData?.activationData?.representationData?.perceptionData?.intent;

    // 简单问候不需要生成
    if (intent === 'greeting') return false;

    // 记忆覆盖度低时需要生成
    if (recollection.coverage < 0.5) return true;

    // 复杂问题需要生成
    const complexity = recollection.associationData?.activationData?.representationData?.perceptionData?.complexity;
    if (complexity === 'complex') return true;

    return true;
  }

  private buildPrompt(context: any): string {
    return `
基于以下上下文回答用户问题：

用户意图：${context.originalIntent}
关键词：${context.keywords.join(', ')}

相关记忆：
${context.memorySummary}

请给出准确、有帮助的回答。
`.trim();
  }

  private computeResponse(context: any): string {
    // 直接使用记忆组合回复
    if (context.originalIntent === 'greeting') {
      return '你好！有什么可以帮你的吗？';
    }
    return context.memorySummary || '我需要更多信息来回答这个问题。';
  }

  private calculateConfidence(recollection: any, output: any): number {
    let confidence = 0.5;

    // 记忆覆盖度影响
    confidence += recollection.coverage * 0.3;

    // 输出长度影响
    if (typeof output === 'string' && output.length > 50) {
      confidence += 0.1;
    }

    return Math.min(1, confidence);
  }

  private buildCognitiveSummary(recollection: any): any {
    return {
      stages: ['sensation', 'perception', 'representation', 'activation', 'association', 'recollection', 'integration'],
      memoriesUsed: recollection.memories?.length || 0,
      coverage: recollection.coverage,
      strongestAssociations: recollection.associationData?.strongestPaths?.slice(0, 3) || []
    };
  }
}
```

---

## 9.3.9 组装完整管道

```typescript
// pipeline-factory.ts
export function createStandardPipeline(
  memory: MemoryInterface,
  generator: GenerationEngine
): CognitivePipeline {
  const processors = new Map<Stage, StageProcessor>();

  processors.set(Stage.SENSATION, new SensationProcessor());
  processors.set(Stage.PERCEPTION, new PerceptionProcessor());
  processors.set(Stage.REPRESENTATION, new RepresentationProcessor());
  processors.set(Stage.ACTIVATION, new ActivationProcessor(memory));
  processors.set(Stage.ASSOCIATION, new AssociationProcessor(memory));
  processors.set(Stage.RECOLLECTION, new RecollectionProcessor(memory));
  processors.set(Stage.INTEGRATION, new IntegrationProcessor(generator));

  return new CognitivePipeline({
    stages: [
      Stage.SENSATION,
      Stage.PERCEPTION,
      Stage.REPRESENTATION,
      Stage.ACTIVATION,
      Stage.ASSOCIATION,
      Stage.RECOLLECTION,
      Stage.INTEGRATION
    ],
    processors,
    substrate: new AutoSubstrateSelector(),
    memory,
    onStageStart: (stage, exp) => {
      console.log(`[Pipeline] 开始 ${stage}`);
    },
    onStageEnd: (stage, exp) => {
      console.log(`[Pipeline] 完成 ${stage}`);
    }
  });
}

// 使用示例
const pipeline = createStandardPipeline(memory, generator);
const result = await pipeline.process('帮我优化这段 React 代码');

console.log(result.content.output);
console.log(result.content.cognitiveSummary);
```

---

## 本节要点

1. **七阶段管道**：Sensation → Perception → Representation → Activation → Association → Recollection → Integration
2. **Sensation**：原始输入接收与标准化
3. **Perception**：意图识别、实体提取、情感分析
4. **Representation**：关键词提取、语义编码
5. **Activation**：激活记忆网络中的相关节点
6. **Association**：扩散激活，建立联想
7. **Recollection**：召回和排序记忆
8. **Integration**：整合信息，生成输出

---

## 下一步

实现了七阶段管道后，下一节我们将深入双基质策略设计，学习如何智能选择 Computation 或 Generation。

---

[上一节：Experience 与 Evolution 实战](9.2-Experience与Evolution实战.md) | [下一节：双基质策略设计](9.4-双基质策略设计.md)
