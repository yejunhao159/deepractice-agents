# 5.4 Luban：为什么能创建工具

> AI 是用户，人类是指挥官，工具是 AI 的装备

上一节，我们深入了解了 Nuwa 的角色创建哲学。本节，我们来探讨 **Luban（鲁班）**——PromptX 中的工具创建专家。

Luban 的设计蕴含着一个颠覆性的观点：

> **工具不是为人类设计的，而是为 AI 设计的**

---

## 传统思维的误区

### 工具是给人用的？

传统的软件工具设计思路：

```
人类 → 学习工具 → 使用工具 → 完成任务

例如：
人类 → 学习 Excel → 操作 Excel → 完成数据分析
```

在这个模型中：
- **人类**是工具的用户
- **工具**是给人类用的界面
- **学习成本**由人类承担

### AI 时代的范式转变

但在 AI 时代，这个模型被颠覆了：

```
人类 → 说话 → AI → 使用工具 → 完成任务

例如：
人类 → "帮我分析这份销售数据" → AI → 调用 Excel API → 返回分析结果
```

在这个新模型中：
- **AI** 成为了工具的用户
- **人类** 只需要说话（决策者）
- **学习成本** 由 AI 承担

---

## Luban 的核心理念

### 理念一：AI 是用户，人类是指挥官

这是 Luban 最核心的设计理念：

```
┌─────────────────────────────────────────────────────────────┐
│                     新的层级关系                             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│     人类（指挥官）                                           │
│       │                                                     │
│       │ 自然语言指令                                         │
│       │ "帮我把这份 Excel 的销售数据做个可视化"              │
│       ▼                                                     │
│     AI（执行者/工具用户）                                    │
│       │                                                     │
│       │ 工具调用                                             │
│       │ tool://excel-tool.read({ path: "sales.xlsx" })     │
│       │ tool://chart-tool.create({ type: "bar", ... })     │
│       ▼                                                     │
│     软件/文件（被操作对象）                                  │
│       • Excel 文件                                          │
│       • 图表库                                              │
│       • 文件系统                                            │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**关键洞察**：
- 人类不需要学会用 Excel，只需要说清楚想要什么
- AI 承担了"学习工具"的成本
- 工具的设计应该对 **AI 友好**，而非对人类友好

### 理念二：工具是 AI 的装备，不是人类的软件

传统软件强调"用户体验"——对人类友好的界面。

但给 AI 用的工具，需要完全不同的设计：

| 维度 | 人类软件 | AI 工具 |
|-----|---------|--------|
| 界面 | 图形界面（GUI） | 函数接口（API） |
| 文档 | 用户手册（人类阅读） | 函数签名 + 描述（AI 理解） |
| 错误处理 | 弹窗提示 | 结构化错误信息 |
| 输入 | 表单、点击 | 参数对象 |
| 输出 | 渲染后的视图 | 结构化数据 |

**例子：读取 Excel**

给人类用的软件：
```
1. 打开 Excel 应用
2. 点击 "文件" → "打开"
3. 浏览到文件位置
4. 双击打开
5. 肉眼查看数据
```

给 AI 用的工具：
```typescript
// AI 调用
const result = await excelTool.read({
  path: "/data/sales.xlsx",
  sheet: "Sheet1",
  range: "A1:D100"
});

// 返回结构化数据
{
  success: true,
  data: [
    { "产品": "iPhone", "销量": 1000, "金额": 8000000 },
    { "产品": "iPad", "销量": 500, "金额": 2500000 },
    ...
  ],
  metadata: {
    rows: 100,
    columns: 4
  }
}
```

### 理念三：集成优于开发，连接优于创造

Luban 的实践方法论：

> **不要重新发明轮子，而是连接现有的轮子**

大多数情况下，我们需要的功能已经有现成的 API 或服务了：
- 发送邮件 → 邮件服务 API
- 操作数据库 → 数据库客户端
- 读取文档 → 文档解析库
- 调用外部服务 → REST/GraphQL API

Luban 的工作是**把这些现有能力"翻译"成 AI 能用的工具**。

```
┌─────────────────────────────────────────────────────────────┐
│                    Luban 的工作                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   现有 API/服务              AI 可用的工具                   │
│   ┌─────────────┐           ┌─────────────┐                │
│   │ Confluence  │   Luban   │ confluence  │                │
│   │  REST API   │ ────────▶ │   -tool     │                │
│   └─────────────┘   翻译    └─────────────┘                │
│                                                             │
│   ┌─────────────┐           ┌─────────────┐                │
│   │   Notion    │   Luban   │   notion    │                │
│   │     API     │ ────────▶ │   -tool     │                │
│   └─────────────┘   翻译    └─────────────┘                │
│                                                             │
│   ┌─────────────┐           ┌─────────────┐                │
│   │   公司内部   │   Luban   │  internal   │                │
│   │     API     │ ────────▶ │   -tool     │                │
│   └─────────────┘   翻译    └─────────────┘                │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## Token 经济学：AI 上下文的成本意识

Luban 在设计工具时，有一个重要的考量：**Token 经济学**。

### AI 的上下文限制

大语言模型有上下文窗口的限制（通常 128k-200k tokens）。工具返回的数据会直接占用这个空间：

```
用户问题（100 tokens）
    +
系统提示（2000 tokens）
    +
角色定义（500 tokens）
    +
工具返回（??? tokens）  ← 这里可能很大！
    +
AI 思考空间（??? tokens）
    =
上下文窗口（128k）
```

如果工具返回的数据太大，会挤占 AI 的"思考空间"。

### 问题：返回太多数据

```typescript
// ❌ 糟糕的工具设计
const result = await excelTool.read({
  path: "/data/huge-report.xlsx"
});

// 返回 10000 行数据，每行 500 字符
// = 5,000,000 字符 ≈ 1,000,000+ tokens
// 直接超出上下文窗口！
```

### 解决方案：给 AI "索引"而非"全文"

```typescript
// ✅ 好的工具设计
const result = await excelTool.read({
  path: "/data/huge-report.xlsx",
  preview: true,      // 只返回预览
  maxRows: 10,        // 最多 10 行
  summarize: true     // 返回统计摘要
});

// 返回
{
  success: true,
  preview: [
    { "产品": "iPhone", "销量": 1000 },
    { "产品": "iPad", "销量": 500 },
    // ... 只有 10 行
  ],
  summary: {
    totalRows: 10000,
    columns: ["产品", "销量", "金额", "日期"],
    dateRange: "2024-01-01 ~ 2024-12-31"
  },
  hint: "数据量较大，建议使用 filter 参数筛选特定范围"
}
```

### Token 经济学的核心原则

| 原则 | 说明 |
|-----|------|
| **索引优于全文** | 返回摘要和索引，而非完整数据 |
| **分页加载** | 支持分批获取，而非一次全返回 |
| **按需筛选** | 提供 filter 参数，让 AI 可以精确获取 |
| **渐进式详情** | 先返回概要，AI 需要时再获取详情 |

---

## 工具的三层结构

Luban 创建的工具遵循三层结构：

### 第一层：接口描述（给 AI 看）

```yaml
# tool://excel-tool 的接口描述
name: excel-tool
description: "读取和写入 Excel 文件"

actions:
  read:
    description: "读取 Excel 文件内容"
    parameters:
      path:
        type: string
        required: true
        description: "Excel 文件路径"
      sheet:
        type: string
        description: "工作表名称，默认第一个"
      range:
        type: string
        description: "单元格范围，如 A1:D100"
      maxRows:
        type: number
        default: 100
        description: "最多返回行数，防止数据过大"

    returns:
      success: boolean
      data: array
      metadata: object
```

AI 通过阅读这个描述，就知道：
- 这个工具能做什么
- 需要传什么参数
- 会返回什么结果

### 第二层：执行逻辑（实际运行）

```typescript
// 实际的执行代码
class ExcelTool {
  async read(params: ReadParams): Promise<ReadResult> {
    // 1. 参数校验
    if (!params.path) {
      return { success: false, error: "path is required" };
    }

    // 2. 读取文件
    const workbook = await xlsx.readFile(params.path);

    // 3. 获取指定工作表
    const sheet = workbook.Sheets[params.sheet || workbook.SheetNames[0]];

    // 4. 解析数据（考虑 token 经济学）
    const data = this.parseSheet(sheet, {
      range: params.range,
      maxRows: params.maxRows || 100
    });

    // 5. 返回结构化结果
    return {
      success: true,
      data,
      metadata: {
        rows: data.length,
        columns: Object.keys(data[0] || {}),
        totalRows: this.getTotalRows(sheet)
      }
    };
  }
}
```

### 第三层：使用手册（manual）

每个工具都有一份"使用手册"，帮助 AI 理解使用场景和最佳实践：

```markdown
# Excel Tool 使用手册

## 适用场景
- 读取 Excel/CSV 数据进行分析
- 将处理结果写入 Excel
- 格式转换（Excel ↔ JSON）

## 使用示例

### 读取数据
```yaml
tool: tool://excel-tool
mode: execute
parameters:
  action: read
  path: /data/sales.xlsx
  maxRows: 50
```

### 写入数据
```yaml
tool: tool://excel-tool
mode: execute
parameters:
  action: write
  path: /output/report.xlsx
  data: [{ "name": "test", "value": 100 }]
```

## 注意事项
- 大文件建议使用 maxRows 限制返回行数
- 复杂公式的单元格会返回计算后的值
- 支持 .xlsx 和 .csv 格式
```

---

## Luban 创建工具的流程

### 流程概览

```
┌─────────────────────────────────────────────────────────────┐
│                    Luban 工具创建流程                        │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   1. 用户描述需求                                            │
│      "我想让 AI 能查询公司的 Jira 任务"                       │
│            │                                                │
│            ▼                                                │
│   2. 理解现有 API                                           │
│      • Jira 有哪些 API？                                    │
│      • 认证方式是什么？                                      │
│      • 常用的操作有哪些？                                    │
│            │                                                │
│            ▼                                                │
│   3. 设计 AI 友好的接口                                     │
│      • 简化参数（AI 容易理解）                               │
│      • 结构化返回（AI 容易处理）                             │
│      • 考虑 Token 经济学                                    │
│            │                                                │
│            ▼                                                │
│   4. 实现工具适配                                           │
│      • 封装 Jira API 调用                                   │
│      • 处理认证和错误                                        │
│      • 格式化返回数据                                        │
│            │                                                │
│            ▼                                                │
│   5. 编写使用手册                                           │
│      • 使用场景说明                                          │
│      • 参数和返回值文档                                      │
│      • 示例代码                                              │
│            │                                                │
│            ▼                                                │
│   6. 注册到 PromptX                                         │
│      AI 可以通过 tool://jira-tool 使用                      │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 实战：创建 Jira 工具

假设用户需要让 AI 能查询和更新 Jira 任务。

**Luban 的探索对话**：

```
用户：我想让 AI 能操作我们的 Jira

Luban：好的，让我了解一下你的需求。

1. 你们用的是 Jira Cloud 还是 Jira Server？
2. AI 需要哪些操作？只是查询，还是也需要创建/更新任务？
3. 有没有权限限制？比如只能操作某些项目？

用户：Jira Cloud，需要查询任务和更新状态，只能操作 DEV 项目。

Luban：明白了。我会为你创建一个 jira-tool，包含以下功能：
- 查询任务（按项目、状态、负责人筛选）
- 获取任务详情
- 更新任务状态

认证方面，你需要提供：
- Jira 域名（如 yourcompany.atlassian.net）
- API Token（在 Jira 设置中生成）

这些敏感信息会存在本地环境变量中，不会暴露给 AI 模型。
```

**生成的工具配置**：

```yaml
# tools/jira-tool/tool.yaml

name: jira-tool
description: "查询和更新 Jira 任务（限 DEV 项目）"

config:
  env:
    JIRA_DOMAIN: "环境变量：Jira 域名"
    JIRA_API_TOKEN: "环境变量：API Token"
    JIRA_EMAIL: "环境变量：用户邮箱"

actions:
  search:
    description: "搜索任务"
    parameters:
      project:
        type: string
        default: "DEV"
        description: "项目 key，限制为 DEV"
      status:
        type: string
        enum: ["To Do", "In Progress", "Done"]
        description: "任务状态"
      assignee:
        type: string
        description: "负责人"
      maxResults:
        type: number
        default: 20
        description: "最多返回数量"

  getIssue:
    description: "获取任务详情"
    parameters:
      issueKey:
        type: string
        required: true
        description: "任务 key，如 DEV-123"

  updateStatus:
    description: "更新任务状态"
    parameters:
      issueKey:
        type: string
        required: true
      newStatus:
        type: string
        required: true
        enum: ["To Do", "In Progress", "Done"]

security:
  allowed_projects: ["DEV"]
  sensitive_fields: ["JIRA_API_TOKEN"]
```

---

## 内置工具介绍

PromptX 提供了几个开箱即用的内置工具：

### tool://filesystem

文件系统操作工具。

```yaml
actions:
  read: "读取文件内容"
  write: "写入文件"
  list: "列出目录内容"
  delete: "删除文件"
  copy: "复制文件"
  move: "移动文件"
```

**使用场景**：
- 读取配置文件
- 保存生成的内容
- 管理项目文件

### tool://pdf-reader

PDF 文档阅读工具。

```yaml
actions:
  extract: "提取 PDF 文本"
  getInfo: "获取 PDF 元信息"
  getPages: "获取页数"
```

**Token 经济学设计**：
- 支持指定页码范围
- 返回分页摘要而非全文
- 大文件自动分块

### tool://excel-tool

Excel 处理工具。

```yaml
actions:
  read: "读取 Excel 数据"
  write: "写入 Excel"
  analyze: "数据分析（求和、平均等）"
```

**Token 经济学设计**：
- maxRows 限制返回行数
- summarize 选项返回统计摘要
- 支持指定单元格范围

### tool://word-tool

Word 文档处理工具。

```yaml
actions:
  read: "读取 Word 内容"
  write: "写入 Word"
  convert: "格式转换"
```

---

## ToolX：工具运行时

所有工具通过 **ToolX** 统一管理和执行。

### 调用方式

AI 通过 YAML 格式调用工具：

```yaml
tool: tool://excel-tool
mode: execute
parameters:
  action: read
  path: /data/sales.xlsx
  maxRows: 50
```

### mode 参数说明

| mode | 作用 |
|------|------|
| `manual` | 查看工具使用手册（必须先读） |
| `execute` | 执行工具操作 |
| `configure` | 配置环境变量 |
| `log` | 查看执行日志 |
| `dryrun` | 模拟执行（不实际运行） |

### 使用流程

```
AI 发现工具
    ↓
mode: manual（阅读使用手册）
    ↓
理解工具能力和参数
    ↓
mode: execute（实际执行）
    ↓
处理返回结果
```

**重要约束**：使用任何工具前，AI 必须先 `mode: manual` 阅读使用手册。这确保 AI 理解工具的正确用法。

---

## 本节小结

### Luban 的核心理念

| 理念 | 含义 |
|-----|------|
| AI 是用户，人类是指挥官 | 工具的用户是 AI，人类只需说话 |
| 工具是 AI 的装备 | 工具设计要对 AI 友好，而非对人类友好 |
| 集成优于开发 | 连接现有 API，而非重新开发 |

### Token 经济学

| 原则 | 做法 |
|-----|------|
| 索引优于全文 | 返回摘要而非完整数据 |
| 分页加载 | 支持分批获取 |
| 按需筛选 | 提供 filter 参数 |
| 渐进式详情 | 先概要，后详情 |

### 工具三层结构

| 层次 | 作用 | 受众 |
|-----|------|------|
| 接口描述 | 定义能力和参数 | AI |
| 执行逻辑 | 实际运行代码 | 运行时 |
| 使用手册 | 使用场景和最佳实践 | AI |

---

下一节，我们将深入探讨 PromptX 最核心的创新——**Engram 记忆网络**。这是让 AI 真正拥有"认知"能力的关键。

---

[上一节：Nuwa 角色创建](5.3-Nuwa角色创建.md) | [返回目录](README.md) | [下一节：Engram 记忆网络](5.5-Engram记忆网络.md)
