# 6.4 PATEOAS：让 AI 拥有连续状态

> Prompt as the Engine of Application State

在上一节中，我们讨论了 AI 任务状态机如何保证协作的原子性和一致性。但状态机的关键在于：**谁来管理状态？**

传统架构中，状态由服务端管理。但在 AI 时代，我们需要一种新的思路。

这就是 PATEOAS —— **Prompt as the Engine of Application State**。

---

## 6.4.1 从 HATEOAS 到 PATEOAS

### REST 与 HATEOAS

如果你熟悉 RESTful API 设计，可能听说过 HATEOAS（Hypermedia as the Engine of Application State）。

这是 REST 的最高成熟度级别：

```
传统 API：
客户端需要预先知道所有 API 端点和调用顺序

HATEOAS：
服务器在响应中告诉客户端"接下来可以做什么"

示例：
{
  "user": {"id": 123, "name": "张三"},
  "links": [
    {"rel": "orders", "href": "/users/123/orders"},
    {"rel": "profile", "href": "/users/123/profile"},
    {"rel": "logout", "href": "/logout"}
  ]
}
```

**核心思想**：超媒体（链接）驱动状态转换，客户端无需预先编码所有路径。

### PATEOAS 的类比

PATEOAS 将同样的思想应用于 AI 系统：

```
传统 AI 交互：
用户需要精确描述每一步操作

PATEOAS：
AI 的提示词中包含"接下来可以做什么"

示例：
你已完成需求分析，当前状态：ANALYZED
可用操作：
- 进入技术设计阶段 [→ DESIGNING]
- 补充需求细节 [→ ANALYZING]
- 取消任务 [→ CANCELLED]
```

**核心思想**：提示词（Prompt）驱动状态转换，AI 无需预先编码所有路径。

---

## 6.4.2 PATEOAS 的核心概念

### 定义

**PATEOAS**（Prompt as the Engine of Application State）是一种 AI 系统状态管理范式：

> 提示词不仅是指令，更是状态的载体和转换的引擎。

### 三个关键要素

| 要素 | 传统架构 | PATEOAS |
|-----|---------|---------|
| **状态存储** | 服务端数据库 | 提示词上下文 |
| **状态转换** | 代码逻辑 | 提示词指令 |
| **可用操作** | API 文档 | 提示词中的选项 |

### 与传统方法的对比

```
传统 AI 架构：
┌─────────────────────────────────────────────────────┐
│  用户 → 提示词 → AI → 响应                           │
│         ↓                                           │
│      [无状态]                                        │
│         ↓                                           │
│  用户 → 新提示词 → AI → 响应（无记忆）               │
└─────────────────────────────────────────────────────┘

PATEOAS 架构：
┌─────────────────────────────────────────────────────┐
│  用户 → 提示词(状态₀) → AI → 响应 + 状态₁           │
│                              ↓                      │
│                         [状态持续]                   │
│                              ↓                      │
│  用户 → 提示词(状态₁) → AI → 响应 + 状态₂           │
└─────────────────────────────────────────────────────┘
```

---

## 6.4.3 状态在提示词中的表达

### 显式状态声明

```markdown
## 当前状态

**任务**：开发用户登录模块
**阶段**：技术设计
**状态码**：DESIGNING
**进度**：40%

**已完成**：
- [x] 需求分析
- [x] 用户故事编写

**待完成**：
- [ ] 技术方案设计
- [ ] 代码实现
- [ ] 测试验证
```

### 可用操作声明

```markdown
## 可用操作

基于当前状态，你可以执行以下操作：

1. **继续设计** [design:continue]
   - 完成技术方案的剩余部分
   - 预期结果：进入 DESIGNED 状态

2. **请求评审** [design:review]
   - 提交当前方案供评审
   - 预期结果：等待反馈

3. **回退需求** [requirement:revise]
   - 发现需求不清，需要补充
   - 预期结果：回到 ANALYZING 状态

4. **暂停任务** [task:pause]
   - 保存当前进度，稍后继续
   - 预期结果：进入 PAUSED 状态
```

### 状态转换历史

```markdown
## 状态转换历史

| 时间 | 从状态 | 到状态 | 触发操作 | 操作者 |
|-----|-------|-------|---------|-------|
| 10:00 | CREATED | ANALYZING | 开始分析 | 产品经理 |
| 10:30 | ANALYZING | ANALYZED | 完成分析 | 产品经理 |
| 11:00 | ANALYZED | DESIGNING | 开始设计 | 架构师 |
| 11:45 | DESIGNING | DESIGNING | 继续设计 | 架构师 |
```

---

## 6.4.4 PATEOAS 的优势

### 优势一：自描述性

AI 不需要预先知道所有可能的操作，因为每个状态的提示词都包含可用操作。

```
传统方式：
AI 需要记住复杂的状态转换规则

PATEOAS 方式：
AI 只需读取当前提示词中的"可用操作"
```

**类比**：就像网页中的链接，用户不需要记住所有 URL，只需点击当前页面上的链接。

### 优势二：灵活演进

系统可以动态调整可用操作，无需修改 AI 的核心逻辑。

```
场景：新增"紧急处理"操作

传统方式：
需要修改 AI 的代码或 System Prompt

PATEOAS 方式：
只需在特定状态的提示词中添加新选项
```

### 优势三：可追溯性

每次状态转换都有记录，便于回溯和审计。

```
问：这个 bug 是怎么产生的？

查看状态历史：
ANALYZING → DESIGNED (跳过了 DESIGNING？)

发现：设计阶段被跳过，导致技术方案不完整
```

### 优势四：多智能体协调

不同 AI 可以共享状态上下文，实现协调。

```
架构师 AI：
当前状态：DESIGNED
我已完成技术方案，请工程师 AI 接手

工程师 AI：
读取状态：DESIGNED
可用操作：[开始实现] [请求澄清] [拒绝接手]
选择：开始实现 → 状态变为 IMPLEMENTING
```

---

## 6.4.5 实现模式

### 模式一：状态嵌入式

状态直接嵌入在对话上下文中。

```python
def create_stateful_prompt(task, current_state, available_actions):
    return f"""
## 任务上下文
{task.description}

## 当前状态
状态码：{current_state.code}
阶段：{current_state.phase}
数据：{current_state.data}

## 可用操作
{format_actions(available_actions)}

## 你的任务
根据当前状态，选择一个操作执行，并输出：
1. 选择的操作及理由
2. 操作执行结果
3. 新的状态
"""
```

### 模式二：状态引用式

状态存储在外部，提示词中只包含引用。

```python
def create_reference_prompt(task_id, state_id):
    return f"""
## 任务引用
任务 ID：{task_id}
状态 ID：{state_id}

请使用 get_state 工具获取当前状态。
请使用 get_actions 工具获取可用操作。
执行完成后，使用 update_state 工具更新状态。
"""
```

### 模式三：混合式

关键状态嵌入，详细数据引用。

```python
def create_hybrid_prompt(task, state_summary, state_ref):
    return f"""
## 任务概要
{task.summary}

## 状态概要（快速参考）
阶段：{state_summary.phase}
进度：{state_summary.progress}%
关键决策：{state_summary.key_decisions}

## 详细状态
如需详细信息，请查询状态 ID：{state_ref}

## 可用操作
{state_summary.available_actions}
"""
```

---

## 6.4.6 PATEOAS 与 PromptX 的结合

PATEOAS 可以与第五章介绍的 PromptX 无缝结合。

### 角色状态管理

```
Nuwa 创建的角色 + PATEOAS 状态管理

角色：投资顾问
├── 身份信息（Nuwa 定义）
├── 当前状态（PATEOAS）
│   ├── 正在处理：客户 A 的投资组合
│   ├── 状态：ANALYZING
│   └── 可用操作：[深入分析] [生成报告] [请求信息]
└── 历史记忆（Engram）
    └── 客户 A 偏好保守型投资
```

### 工具调用状态

```
Luban 创建的工具 + PATEOAS 状态跟踪

工具调用链：
1. 获取市场数据 [COMPLETED]
2. 分析投资组合 [IN_PROGRESS]
3. 生成建议报告 [PENDING]

当前可用操作：
- 继续分析 → 完成步骤 2
- 暂停分析 → 保存中间结果
- 取消任务 → 回滚所有变更
```

### 记忆状态演化

```
Engram 记忆 + PATEOAS 演化追踪

记忆演化历史：
T1: remember("客户偏好保守投资") → 记忆强度 0.8
T2: recall("客户偏好") → 命中，强度提升至 0.85
T3: 新信息冲突 → 记忆更新，强度调整至 0.7
T4: 多次验证 → 强度稳定在 0.9
```

---

## 6.4.7 实践案例

### 案例：多智能体开发团队

使用 PATEOAS 管理开发任务状态：

```
任务：实现用户认证模块

初始状态：
{
  code: "CREATED",
  phase: "初始化",
  owner: null,
  data: { requirement: "用户登录注册功能" }
}

阶段 1 - 需求分析（产品经理 AI）
{
  code: "ANALYZED",
  phase: "需求已分析",
  owner: "PM-AI",
  data: {
    requirement: "...",
    user_stories: ["作为用户，我想要...", ...],
    acceptance_criteria: [...]
  },
  available_actions: ["start_design", "revise_requirement"]
}

阶段 2 - 技术设计（架构师 AI）
{
  code: "DESIGNED",
  phase: "设计已完成",
  owner: "Architect-AI",
  data: {
    ...previous_data,
    tech_stack: ["Node.js", "PostgreSQL", "JWT"],
    api_design: {...},
    db_schema: {...}
  },
  available_actions: ["start_implementation", "revise_design"]
}

阶段 3 - 代码实现（工程师 AI）
{
  code: "IMPLEMENTED",
  phase: "开发已完成",
  owner: "Engineer-AI",
  data: {
    ...previous_data,
    code_files: ["auth.ts", "user.ts", ...],
    test_files: ["auth.test.ts", ...]
  },
  available_actions: ["start_testing", "fix_bugs"]
}

阶段 4 - 测试验证（测试 AI）
{
  code: "VERIFIED",
  phase: "测试已通过",
  owner: "QA-AI",
  data: {
    ...previous_data,
    test_results: { passed: 47, failed: 0 },
    coverage: "92%"
  },
  available_actions: ["deploy", "add_tests"]
}

最终状态：
{
  code: "COMPLETED",
  phase: "已完成",
  owner: null,
  data: { ...all_accumulated_data },
  available_actions: ["archive", "start_new_task"]
}
```

### 状态转换可视化

```
CREATED ─────→ ANALYZING ─────→ ANALYZED
                  │                 │
                  ↓                 ↓
              (取消)            DESIGNING ─────→ DESIGNED
                                   │                 │
                                   ↓                 ↓
                               (重新分析)       IMPLEMENTING ─────→ IMPLEMENTED
                                                    │                    │
                                                    ↓                    ↓
                                                (重新设计)          TESTING ─────→ VERIFIED
                                                                        │              │
                                                                        ↓              ↓
                                                                   (修复 bug)     COMPLETED
```

---

## 6.4.8 与其他范式的关系

### PATEOAS vs 传统工作流

| 维度 | 传统工作流 | PATEOAS |
|-----|----------|---------|
| 状态定义 | 预先固定 | 动态生成 |
| 转换规则 | 硬编码 | 提示词描述 |
| 灵活性 | 低 | 高 |
| 可追溯性 | 依赖日志 | 内建历史 |

### PATEOAS vs 有限状态机

| 维度 | 有限状态机 | PATEOAS |
|-----|----------|---------|
| 状态数量 | 预先有限 | 可动态扩展 |
| 转换条件 | 形式化 | 自然语言 |
| 实现复杂度 | 较高 | 较低 |
| AI 友好度 | 需适配 | 原生支持 |

### PATEOAS 与 4P 理论

```
4P 理论的每个层级都可以用 PATEOAS 管理状态：

L1 Prompt Pattern 层：模式的生命周期状态
L2 Domain Prompt 层：领域模板的演化状态
L3 Scenario Project 层：项目执行状态（最常用）
L4 Realization Product 层：产品运行状态
```

---

## 本节要点

1. **PATEOAS 定义**：Prompt as the Engine of Application State，提示词驱动状态管理
2. **核心思想**：状态不由外部系统管理，而是内嵌于提示词中
3. **三要素**：状态存储、状态转换、可用操作都在提示词中表达
4. **四大优势**：自描述性、灵活演进、可追溯性、多智能体协调
5. **实现模式**：嵌入式、引用式、混合式
6. **与 PromptX 结合**：角色状态、工具调用、记忆演化的统一管理

---

## 延伸阅读

- [PATEOAS 项目](https://github.com/Deepractice/PATEOAS) - 开源实现
- [HATEOAS 原理](https://en.wikipedia.org/wiki/HATEOAS) - REST 成熟度模型
- [状态机设计模式](https://refactoring.guru/design-patterns/state) - 经典设计模式

---

[上一节：AI 任务状态机](6.3-AI任务状态机.md) | [下一节：AI 组织化](6.5-AI组织化.md)
