# 6.3 AI 任务状态机：原子性与一致性

> 用状态机思想重新设计 AI 协作

在上一节中，我们学习了 4P 理论，建立了从提示词到产品的系统化路径。但还有一个关键问题没有解决：

**如何保证 AI 协作过程的可靠性？**

本节将介绍 Deepractice 提出的 AI 任务状态机模型，它用状态机思想解决了 AI 协作中的三大痛点。

---

## 6.3.1 AI 协作的三大痛点

### 痛点一：上下文丢失

```
你：帮我重构这个登录模块，记得要保持向后兼容
AI：好的，我重构了（30分钟后）
你：测试覆盖率怎么样？
AI：什么测试覆盖率？你之前没提过啊
```

**问题本质**：AI 没有"工作记忆"，重要约束在对话中丢失。

### 痛点二：目标漂移

```
你：修复这个 bug，顺便优化一下性能
AI：（开始重构整个架构）
你：等等！我只是要修个 bug！
AI：但是这样更好啊...
```

**问题本质**：没有明确的"完成标准"，AI 自行扩展任务范围。

### 痛点三：无法验证

```
你：任务完成了吗？
AI：完成了
你：真的完成了？测试通过了吗？文档更新了吗？
AI：呃...你说的"完成"是指...
```

**问题本质**："完成"的定义模糊，无法客观验证。

---

## 6.3.2 状态机思维的引入

### 什么是状态机？

别被"状态机"这个词吓到，其实你天天在用：

**红绿灯就是状态机**
```
当前状态：红灯
输入条件：等待 30 秒
下一状态：绿灯
验证标准：灯变绿了
```

**自动售货机也是状态机**
```
当前状态：等待投币
输入条件：投入 5 元硬币
下一状态：可以选商品
验证标准：屏幕显示"请选择商品"
```

### 状态机的核心思想

1. 明确"现在在哪"（当前状态）
2. 明确"要去哪"（目标状态）
3. 明确"怎么去"（转移条件）
4. 明确"到了没"（验证标准）

这正是 AI 协作所缺失的！

---

## 6.3.3 AI 任务状态机：五要素模型

我们把状态机思想映射到 AI 任务管理，定义五个核心要素：

```
┌─────────────────────────────────────────────────────────┐
│                    AI 任务状态机                         │
├─────────────────────────────────────────────────────────┤
│                                                         │
│   ┌─────────┐                         ┌─────────┐      │
│   │  初始   │  ─── 转移函数 δ ───→    │  目标   │      │
│   │  状态   │      (AI 执行)          │  状态   │      │
│   │  q₀     │                         │  F      │      │
│   └─────────┘                         └─────────┘      │
│        │                                   │           │
│        └───────────┬───────────────────────┘           │
│                    │                                    │
│              ┌─────┴─────┐                             │
│              │  上下文   │                             │
│              │  空间 Σ   │                             │
│              └───────────┘                             │
│                                                         │
│   生产态空间 Q：任务执行过程中所有可能的工作成果状态      │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 要素一：初始状态 (q₀)

**定义**：任务开始时，系统是什么样的。

**注意**：不是"要做什么"（那是任务需求），而是"现在是什么样"。

**示例：重构登录模块**

```yaml
初始状态:
  代码：
    - auth.js 有 350 行
    - 包含 login/logout/validateToken 三个函数
  测试：
    - 15 个测试用例
    - 覆盖率 60%
    - 全部通过
  文档：
    - README 有基础说明
    - 缺少 API 文档
  已知问题：
    - 密码重置功能有 bug
    - session 过期时间过短
```

### 要素二：目标状态 (F)

**定义**：任务完成时，系统应该变成什么样。

**关键**：这是一个**集合**，不是单一状态（允许多种可接受的完成状态）。

**示例**：

```yaml
完美完成:
  代码：重构完成，复杂度降低，性能提升 20%
  测试：覆盖率 > 90%，所有测试通过
  文档：完整的 API 文档 + 迁移指南
  问题：所有已知 bug 修复

可接受完成:
  代码：重构完成，向后兼容
  测试：覆盖率 > 80%，主要测试通过
  文档：API 文档完成

最小可交付:
  代码：核心功能重构完成
  测试：主路径测试通过
  文档：README 更新
```

### 要素三：上下文空间 (Σ)

**定义**：任务执行需要的所有背景信息。

**关键**：这些信息在任务执行期间**不变**（或缓慢变化）。

分为四层：

| 层次 | 内容 | 示例 |
|------|------|------|
| **信息层** | 现有代码、设计文档、API 规范 | 现有 auth.js 源码、技术方案文档 |
| **约束层** | 技术栈、性能要求、兼容性 | 必须使用 TypeScript、支持 Chrome 90+ |
| **规范层** | 代码风格、测试要求、提交规范 | ESLint 配置、覆盖率 > 80% |
| **关联层** | 依赖任务、后续任务、并行任务 | 用户模块已完成，支付模块等待本任务 |

### 要素四：转移函数 (δ)

**定义**：AI 本身的执行能力。

这是 AI（或智能体）的工作：

```yaml
AI 的能力:
  理解：理解初始状态和目标状态
  规划：自主决策执行路径
  执行：调用工具完成工作
  验证：确认是否达到目标状态
```

**关键特点**：
- 我们不控制 AI 内部如何思考（黑盒）
- 我们只控制输入和期望输出
- 相同输入可能产生不同路径（非确定性）

### 要素五：生产态空间 (Q)

**定义**：任务执行过程中所有可能的工作成果状态。

**重要区分**：
- ❌ 运行态：AI 正在读文件、正在思考（我们不关心）
- ✅ 生产态：代码写到什么程度、测试通过多少（我们关心的）

---

## 6.3.4 两个核心保证

### 保证一：原子性

**定义**：任务要么全部完成，要么全部不做。

**传统方式的问题**：

```
你：帮我实现用户注册功能
AI：（写了一半代码）
你：等等，我还要加个验证码
AI：（继续写）
你：不对，邮箱验证也要加上
AI：（代码越来越乱）
最后：半成品，无法使用
```

**状态机方式**：

```yaml
初始状态：用户模块没有注册功能

目标状态：注册功能完整
  - 包括表单、验证、邮件确认

验证标准：
  - 用户可以注册
  - 收到确认邮件
  - 点击链接激活账户
  - 所有测试通过

结果：要么达到这个状态，要么回到初始状态
      中间状态不可交付
```

**如何保证**：
1. 明确定义"完成"的标准（目标状态 F）
2. 任务结束时验证是否达到 F
3. 未达到 F = 任务失败，需要重新执行或回滚

### 保证二：一致性

**定义**：相同输入应该产生相同结果。

**传统方式的问题**：

```
第一次：
你：帮我写个用户认证模块
AI：（用 JWT）

第二次（同样的话）：
你：帮我写个用户认证模块
AI：（用 Session）

你：？？？为什么不一样
```

**状态机方式**：

```yaml
输入固定：
  初始状态: {代码库现状、技术栈、规范...}
  上下文空间: {必须用 JWT、参考已有的权限模块...}
  目标状态: {认证功能完成、测试通过...}

保证：只要这三个输入相同，AI 产出应该一致
      （即使路径可能不同，但最终结果符合目标状态）
```

**如何保证**：
1. 显式定义所有约束（上下文空间 Σ）
2. 包括技术选型、参考实现、设计模式
3. 不依赖"AI 自己判断"

---

## 6.3.5 实战案例：用状态机定义任务

### 需求：为博客系统添加评论功能

#### 传统方式（聊天式）

```
你：帮我加个评论功能
AI：好的（开始写代码）
你：要支持回复
AI：好（加回复功能）
你：还要有点赞
AI：行（继续加）
你：要不要加举报功能？
AI：可以啊（越写越多）
...（3小时后，一团乱麻）
```

#### 状态机方式

**1. 初始状态 (q₀)**

```yaml
代码状态：
  - 已有 Post 模型（标题、内容、作者）
  - 已有用户认证系统
  - 数据库：PostgreSQL

测试状态：
  - Post 相关测试覆盖率 85%

技术栈：
  - 后端：Node.js + Express + TypeORM
  - 前端：React + TypeScript
```

**2. 上下文空间 (Σ)**

| 层次 | 具体内容 |
|------|----------|
| 信息层 | • 现有 Post 模型代码<br>• 用户认证实现方式<br>• 数据库 Schema |
| 约束层 | • 必须使用 TypeORM<br>• 评论不能超过 1000 字<br>• 需要防 XSS 攻击 |
| 规范层 | • RESTful API 设计<br>• 测试覆盖率 > 80%<br>• 代码必须通过 ESLint |
| 关联层 | • 依赖：用户认证模块（已完成）<br>• 并行：前端 UI 改版（进行中） |

**3. 目标状态 (F)**

```yaml
完整完成:
  功能：
    ✓ 用户可以发表评论（需登录）
    ✓ 支持二级回复（回复评论）
    ✓ 支持点赞评论
    ✓ 评论作者可以编辑/删除自己的评论
    ✓ 管理员可以删除任何评论
  质量：
    ✓ 测试覆盖率 > 80%
    ✓ 所有测试通过
    ✓ 通过 ESLint 检查
  文档：
    ✓ API 文档更新
    ✓ 数据库变更记录

可接受完成:
  功能：
    ✓ 用户可以发表评论
    ✓ 支持二级回复
    ✓ 评论作者可以删除自己的评论
  质量：
    ✓ 主路径测试通过
    ✓ 通过 ESLint 检查
```

**4. 验证清单**

```yaml
功能验证：
  - [ ] 登录用户可以发表评论
  - [ ] 未登录用户看到"请先登录"
  - [ ] 评论可以回复
  - [ ] 点赞功能正常
  - [ ] 删除功能正常（权限控制）

技术验证：
  - [ ] npm run test 全部通过
  - [ ] npm run lint 无错误
  - [ ] 评论表已创建
  - [ ] API 文档已更新
```

---

## 6.3.6 状态机与多智能体协作

当多个 AI 协作时，状态机思想更加重要。

### 多智能体状态机

```
┌─────────────────────────────────────────────────────────┐
│                    多智能体任务流                        │
├─────────────────────────────────────────────────────────┤
│                                                         │
│   q₀ ─→ [产品经理AI] ─→ q₁ ─→ [架构师AI] ─→ q₂         │
│                                      │                  │
│                                      ▼                  │
│   F ←── [测试AI] ←── q₃ ←── [工程师AI]                 │
│                                                         │
│   每个阶段：                                            │
│   • 有明确的输入状态                                    │
│   • 有明确的输出状态                                    │
│   • 有明确的验证标准                                    │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 各阶段的状态定义

| 阶段 | 输入状态 | 输出状态 | 验证标准 |
|-----|---------|---------|---------|
| 产品经理 | 用户需求描述 | 需求文档 + 用户故事 | 需求完整、无歧义 |
| 架构师 | 需求文档 | 技术方案 + 接口定义 | 方案可行、符合约束 |
| 工程师 | 技术方案 | 代码实现 | 代码可运行、符合规范 |
| 测试 | 代码实现 | 测试报告 | 测试通过、覆盖率达标 |

### 状态传递协议

```yaml
# 产品经理 → 架构师 的状态传递

from_agent: ProductManager
to_agent: Architect

current_state:
  需求文档: docs/requirements.md
  用户故事: 5 个
  优先级: P0 = 2, P1 = 2, P2 = 1

expected_output:
  技术方案: docs/tech-design.md
  接口定义: api/openapi.yaml
  数据库设计: db/schema.sql

acceptance_criteria:
  - 技术方案覆盖所有 P0 需求
  - 接口定义符合 RESTful 规范
  - 数据库设计通过评审
```

---

## 6.3.7 与 4P 理论的关系

AI 任务状态机是 4P 理论在执行层面的具体化：

```
4P 理论                          AI 任务状态机
─────────                        ──────────────
Prompt Pattern  ──────────→     状态机模型的设计模式
Domain Prompt   ──────────→     特定领域的状态定义模板
Scenario Project ─────────→     具体项目的状态配置
Realization Product ──────→     实际运行的状态机系统
```

---

## 本节要点

1. **三大痛点**：上下文丢失、目标漂移、无法验证
2. **五要素模型**：初始状态 q₀、目标状态 F、上下文空间 Σ、转移函数 δ、生产态空间 Q
3. **两个保证**：原子性（全做或全不做）、一致性（相同输入相同结果）
4. **实践要点**：明确定义"完成"标准，显式声明所有约束
5. **多智能体应用**：每个阶段都有明确的输入/输出状态和验证标准

---

## 延伸阅读

- [AI 任务状态机原文](https://github.com/Deepractice/DeepracticeDocs/blob/main/docs/zh/blog/2025-10-01-ai任务状态机-用状态机思想重新设计ai协作.md)

---

[上一节：4P 理论](6.2-4P理论.md) | [下一节：PATEOAS](6.4-PATEOAS.md)
