# 7.4 运行时系统

> AgentX 的基础设施层

本节将介绍 AgentX 运行时系统的核心组件，包括生命周期管理、外部环境接口和数据持久化。

---

## 7.4.1 Container：生命周期管理

### 什么是 Container

**Container** 是 AgentX 的生命周期容器，负责管理智能体实例的创建、运行和销毁。它是运行时的核心调度器。

```typescript
import { Container } from '@agentxjs/runtime'

const container = new Container()
```

### 智能体注册

```typescript
// 注册智能体配置
container.register('assistant', {
  model: 'claude-sonnet-4-20250514',
  apiKey: process.env.ANTHROPIC_API_KEY,
  systemPrompt: '你是一个通用助手'
})

container.register('coder', {
  model: 'claude-sonnet-4-20250514',
  apiKey: process.env.ANTHROPIC_API_KEY,
  systemPrompt: '你是一个专业的程序员'
})

// 创建实例
const assistant = await container.create('assistant')
const coder = await container.create('coder')
```

### 生命周期钩子

Container 提供完整的生命周期钩子：

```typescript
container.on('beforeCreate', (config) => {
  console.log(`准备创建: ${config.name}`)
})

container.on('afterCreate', (agent) => {
  console.log(`创建完成: ${agent.id}`)
})

container.on('beforeDestroy', (agent) => {
  console.log(`准备销毁: ${agent.id}`)
})

container.on('afterDestroy', (agentId) => {
  console.log(`已销毁: ${agentId}`)
})

container.on('error', (error, agent) => {
  console.error(`错误 [${agent?.id}]:`, error.message)
})
```

### 实例管理

```typescript
// 获取所有实例
const agents = container.getAll()
console.log(`当前 ${agents.length} 个智能体`)

// 通过 ID 获取
const agent = container.get('agent_001')

// 销毁指定实例
await container.destroy('agent_001')

// 销毁所有实例
await container.destroyAll()

// 检查实例状态
const status = container.getStatus('agent_001')
// { state: 'running', uptime: 3600, messageCount: 42 }
```

### 资源限制

```typescript
const container = new Container({
  // 最大实例数
  maxInstances: 100,

  // 单实例最大消息数
  maxMessagesPerAgent: 1000,

  // 空闲超时（自动销毁）
  idleTimeout: 30 * 60 * 1000, // 30 分钟

  // 内存限制
  memoryLimit: 512 * 1024 * 1024 // 512MB
})
```

---

## 7.4.2 Environment：外部环境接口

### 什么是 Environment

**Environment** 是 AgentX 与外部系统交互的接口层，包括 LLM API、MCP 工具服务器等。

```typescript
import { Environment } from '@agentxjs/runtime'

const env = new Environment({
  // LLM 配置
  llm: {
    provider: 'anthropic',
    apiKey: process.env.ANTHROPIC_API_KEY,
    model: 'claude-sonnet-4-20250514'
  },

  // MCP 配置
  mcp: {
    servers: [
      { name: 'filesystem', command: 'npx', args: [...] }
    ]
  }
})
```

### LLM 接口

Environment 封装了 LLM 的调用：

```typescript
// 发送消息
const response = await env.llm.chat({
  messages: [
    { role: 'user', content: '你好' }
  ],
  maxTokens: 1024
})

// 流式调用
const stream = await env.llm.stream({
  messages: [
    { role: 'user', content: '给我讲个故事' }
  ]
})

for await (const chunk of stream) {
  if (chunk.type === 'text_delta') {
    process.stdout.write(chunk.delta)
  }
}

// 获取使用量
const usage = await env.llm.getUsage()
// { inputTokens: 1000, outputTokens: 500, totalCost: 0.05 }
```

### MCP 工具管理

```typescript
// 启动所有 MCP 服务器
await env.mcp.startAll()

// 获取可用工具列表
const tools = await env.mcp.listTools()
// [
//   { name: 'read_file', server: 'filesystem', ... },
//   { name: 'write_file', server: 'filesystem', ... },
//   { name: 'fetch_url', server: 'web-fetch', ... }
// ]

// 调用工具
const result = await env.mcp.callTool('read_file', {
  path: '/path/to/file.txt'
})

// 停止 MCP 服务器
await env.mcp.stopAll()
```

### 多 LLM 支持

```typescript
const env = new Environment({
  llm: {
    providers: {
      anthropic: {
        apiKey: process.env.ANTHROPIC_API_KEY,
        models: ['claude-sonnet-4-20250514', 'claude-opus-4-20250514']
      },
      openai: {
        apiKey: process.env.OPENAI_API_KEY,
        models: ['gpt-4o', 'gpt-4o-mini']
      }
    },
    default: 'anthropic:claude-sonnet-4-20250514'
  }
})

// 使用特定模型
await env.llm.chat({
  model: 'openai:gpt-4o',
  messages: [...]
})
```

### 环境事件

```typescript
env.on('llm:request', (req) => {
  console.log('LLM 请求:', req.messages.length, '条消息')
})

env.on('llm:response', (res) => {
  console.log('LLM 响应:', res.usage)
})

env.on('mcp:tool_call', (call) => {
  console.log('工具调用:', call.name, call.input)
})

env.on('mcp:tool_result', (result) => {
  console.log('工具结果:', result.output)
})

env.on('error', (error) => {
  console.error('环境错误:', error.message)
})
```

---

## 7.4.3 Persistence：数据持久化

### 什么是 Persistence

**Persistence** 是 AgentX 的持久化层，负责存储会话历史、智能体状态等数据。AgentX 提供多种持久化驱动。

### MemoryDriver：内存存储

最简单的驱动，适合开发测试：

```typescript
import { MemoryDriver } from '@agentxjs/runtime'

const persistence = new MemoryDriver()

// 数据存储在内存中
// 程序重启后数据丢失
```

### SQLiteDriver：SQLite 存储

适合单机部署：

```typescript
import { SQLiteDriver } from '@agentxjs/runtime'

const persistence = new SQLiteDriver({
  path: './data/agent.db',

  // 可选配置
  walMode: true,        // WAL 模式，提高并发性能
  busyTimeout: 5000,    // 忙等待超时
  maxConnections: 10    // 最大连接数
})
```

### 持久化接口

所有驱动实现统一接口：

```typescript
interface PersistenceDriver {
  // 会话管理
  createSession(userId: string): Promise<Session>
  getSession(sessionId: string): Promise<Session | null>
  listSessions(userId: string): Promise<Session[]>
  deleteSession(sessionId: string): Promise<void>

  // 消息存储
  saveMessage(sessionId: string, message: Message): Promise<void>
  getMessages(sessionId: string, options?: {
    limit?: number
    before?: string
    after?: string
  }): Promise<Message[]>
  deleteMessages(sessionId: string): Promise<void>

  // 状态存储
  saveState(agentId: string, state: AgentState): Promise<void>
  getState(agentId: string): Promise<AgentState | null>

  // 元数据
  saveMetadata(key: string, value: any): Promise<void>
  getMetadata(key: string): Promise<any>
}
```

### 使用示例

```typescript
import { createAgent, SQLiteDriver } from '@agentxjs/runtime'

const persistence = new SQLiteDriver({ path: './data.db' })

const agent = await createAgent({
  model: 'claude-sonnet-4-20250514',
  apiKey: process.env.ANTHROPIC_API_KEY,
  persistence
})

// 消息自动持久化
await agent.chat('你好')

// 重启后恢复会话
const messages = await agent.getMessages()
console.log(`恢复了 ${messages.length} 条消息`)
```

### 自定义驱动

你可以实现自定义的持久化驱动：

```typescript
import { PersistenceDriver } from '@agentxjs/runtime'

class RedisDriver implements PersistenceDriver {
  private client: Redis

  constructor(config: RedisConfig) {
    this.client = new Redis(config)
  }

  async createSession(userId: string): Promise<Session> {
    const session = {
      id: generateId(),
      userId,
      createdAt: new Date()
    }
    await this.client.hset(`sessions:${userId}`, session.id, JSON.stringify(session))
    return session
  }

  async getMessages(sessionId: string): Promise<Message[]> {
    const messages = await this.client.lrange(`messages:${sessionId}`, 0, -1)
    return messages.map(m => JSON.parse(m))
  }

  // ... 实现其他方法
}
```

---

## 7.4.4 运行时组装

### 完整的运行时配置

```typescript
import {
  createAgent,
  Container,
  Environment,
  SQLiteDriver,
  SystemBus
} from '@agentxjs/runtime'

async function bootstrap() {
  // 1. 创建事件总线
  const bus = new SystemBus()

  // 2. 创建环境
  const env = new Environment({
    llm: {
      provider: 'anthropic',
      apiKey: process.env.ANTHROPIC_API_KEY,
      model: 'claude-sonnet-4-20250514'
    },
    mcp: {
      servers: [
        {
          name: 'filesystem',
          command: 'npx',
          args: ['-y', '@anthropic-ai/mcp-server-filesystem', './']
        }
      ]
    }
  })

  // 3. 创建持久化
  const persistence = new SQLiteDriver({
    path: './data/agent.db'
  })

  // 4. 创建容器
  const container = new Container({
    maxInstances: 100,
    idleTimeout: 30 * 60 * 1000
  })

  // 5. 注册智能体配置
  container.register('default', {
    bus,
    env,
    persistence,
    systemPrompt: '你是一个专业的 AI 助手。'
  })

  // 6. 启动 MCP 服务器
  await env.mcp.startAll()

  // 7. 创建智能体实例
  const agent = await container.create('default')

  return { bus, env, persistence, container, agent }
}
```

### 优雅关闭

```typescript
async function shutdown(runtime: Runtime) {
  console.log('正在关闭...')

  // 1. 停止接收新请求
  runtime.driver.stop()

  // 2. 等待进行中的请求完成
  await runtime.agent.waitForIdle()

  // 3. 保存状态
  await runtime.persistence.saveState(runtime.agent.id, runtime.agent.getState())

  // 4. 销毁智能体
  await runtime.container.destroyAll()

  // 5. 停止 MCP 服务器
  await runtime.env.mcp.stopAll()

  // 6. 关闭数据库连接
  await runtime.persistence.close()

  console.log('已安全关闭')
}

// 监听退出信号
process.on('SIGINT', () => shutdown(runtime))
process.on('SIGTERM', () => shutdown(runtime))
```

---

## 7.4.5 监控与调试

### 健康检查

```typescript
import { HealthCheck } from '@agentxjs/runtime'

const health = new HealthCheck({
  container,
  env,
  persistence
})

// HTTP 健康检查端点
app.get('/health', async (req, res) => {
  const status = await health.check()
  res.json(status)
})

// 返回示例
// {
//   status: 'healthy',
//   components: {
//     container: { status: 'healthy', instances: 5 },
//     llm: { status: 'healthy', latency: 120 },
//     mcp: { status: 'healthy', servers: 2 },
//     persistence: { status: 'healthy', connections: 3 }
//   },
//   timestamp: '2025-12-19T10:00:00Z'
// }
```

### 指标收集

```typescript
import { Metrics } from '@agentxjs/runtime'

const metrics = new Metrics()

// 事件总线指标
bus.on('*', (event) => {
  metrics.increment(`events.${event.type}`)
})

// LLM 指标
env.on('llm:response', (res) => {
  metrics.increment('llm.requests')
  metrics.gauge('llm.tokens.input', res.usage.inputTokens)
  metrics.gauge('llm.tokens.output', res.usage.outputTokens)
  metrics.timing('llm.latency', res.latency)
})

// 导出 Prometheus 格式
app.get('/metrics', (req, res) => {
  res.set('Content-Type', 'text/plain')
  res.send(metrics.export('prometheus'))
})
```

### 调试日志

```typescript
import { Logger } from '@agentxjs/runtime'

const logger = new Logger({
  level: process.env.LOG_LEVEL || 'info',
  format: 'json'
})

// 各组件使用 logger
container.setLogger(logger.child({ component: 'container' }))
env.setLogger(logger.child({ component: 'environment' }))

// 输出示例
// {"level":"info","component":"container","msg":"Agent created","agentId":"agent_001"}
// {"level":"debug","component":"environment","msg":"LLM request","tokens":150}
```

---

## 本节要点

1. **Container**：管理智能体的生命周期，提供资源限制
2. **Environment**：封装 LLM 和 MCP 的调用接口
3. **Persistence**：提供可插拔的持久化驱动
4. **运行时组装**：将各组件组合成完整的运行时
5. **监控调试**：健康检查、指标收集、日志记录

---

## 下一步

了解了运行时系统后，下一节我们将学习如何将 AgentX 与 PromptX 集成，实现角色激活、工具调用和记忆管理。

---

[上一节：核心概念](7.3-核心概念.md) | [下一节：与 PromptX 集成](7.5-与PromptX集成.md)
