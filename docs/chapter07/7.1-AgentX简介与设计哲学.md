# 7.1 AgentX 简介与设计哲学

> 事件驱动的下一代智能体框架

在前面的章节中，我们学习了 PromptX 的认知能力和 Deepractice 的设计方法论。现在，是时候将这些理论付诸实践了。

**AgentX** 是 Deepractice 团队开发的事件驱动智能体框架，它不仅是一个开发工具，更是一种全新的智能体构建范式。

---

## 7.1.1 为什么需要 AgentX

### 现有方案的局限

在第四章中，我们手写实现了 ReAct、Plan-and-Solve 等智能体范式。这些实现虽然能工作，但存在明显的工程问题：

| 问题 | 具体表现 |
|-----|---------|
| **同步阻塞** | 等待 LLM 响应时整个程序阻塞 |
| **状态丢失** | 每次请求都是独立的，无法保持连续状态 |
| **难以扩展** | 添加新功能需要修改核心代码 |
| **缺乏可观测性** | 难以追踪智能体的决策过程 |
| **部署困难** | 从开发到生产需要大量额外工作 |

### AgentX 的解决方案

AgentX 通过**事件驱动架构**解决这些问题：

```
传统方式：
request → wait → response → wait → request → ...
[同步、阻塞、状态丢失]

AgentX 方式：
event → process → event → process → event → ...
[异步、非阻塞、状态连续]
```

---

## 7.1.2 事件驱动架构

### 什么是事件驱动

**事件驱动架构**（Event-Driven Architecture）是一种软件设计模式，系统中的所有操作都通过**事件**进行通信：

```
┌─────────────────────────────────────────────────────────┐
│                    SystemBus（事件总线）                  │
├─────────────────────────────────────────────────────────┤
│                           │                              │
│    ┌──────────┐    ┌─────┴─────┐    ┌──────────┐       │
│    │ Producer │ ──→│   Event   │──→ │ Consumer │       │
│    │ 事件生产者│    │   事件    │    │ 事件消费者│       │
│    └──────────┘    └───────────┘    └──────────┘       │
│                                                          │
│    ┌──────────┐                     ┌──────────┐       │
│    │ Producer │ ─────────────────→ │ Consumer │       │
│    └──────────┘                     └──────────┘       │
│                                                          │
└─────────────────────────────────────────────────────────┘
```

**核心特征**：
- **松耦合**：生产者和消费者不直接依赖
- **异步处理**：事件发出后立即返回，不等待处理完成
- **可扩展**：添加新的处理器不影响现有代码
- **可观测**：所有事件都可以被记录和追踪

### 在智能体中的应用

对于智能体系统，事件驱动特别合适：

```typescript
// 用户输入触发事件
bus.emit('user:message', { content: '帮我写一段代码' })

// AgentEngine 监听并处理
bus.on('user:message', async (msg) => {
  bus.emit('agent:thinking_start')

  // 调用 LLM，流式输出
  for await (const chunk of llm.stream(msg)) {
    bus.emit('agent:text_delta', { delta: chunk })
  }

  bus.emit('agent:thinking_end')
  bus.emit('agent:message_complete', { ... })
})

// UI 监听并更新
bus.on('agent:text_delta', (e) => updateUI(e.delta))
bus.on('agent:thinking_start', () => showSpinner())
bus.on('agent:thinking_end', () => hideSpinner())
```

---

## 7.1.3 Mealy Machine 模式

### 状态机基础

AgentX 的 AgentEngine 采用 **Mealy Machine**（米利机）模式设计。这是一种有限状态机，其输出由**当前状态**和**输入**共同决定：

```
Mealy Machine 转换公式：
(state, input) → (new_state, outputs)

含义：
给定当前状态和输入，产生新状态和输出
```

### 为什么选择 Mealy Machine

与传统的 Moore Machine 相比，Mealy Machine 更适合智能体：

| 特性 | Moore Machine | Mealy Machine |
|-----|--------------|---------------|
| 输出依赖 | 仅依赖状态 | 依赖状态 + 输入 |
| 状态数量 | 较多 | 较少 |
| 响应速度 | 需等状态变化 | 可立即响应 |
| 适用场景 | 简单控制 | 复杂交互 |

### AgentEngine 中的实现

```typescript
// AgentEngine 的状态定义
type AgentState = 'idle' | 'thinking' | 'tool_calling' | 'error'

// 状态转换示例
const transitions = {
  // (当前状态, 输入事件) → (新状态, 输出事件)

  // 空闲状态收到用户消息 → 开始思考
  ['idle', 'user_message']: ['thinking', ['thinking_start']],

  // 思考中收到 LLM 文本块 → 继续思考 + 输出文本
  ['thinking', 'llm_chunk']: ['thinking', ['text_delta']],

  // 思考中收到工具调用 → 转为工具调用状态
  ['thinking', 'tool_use']: ['tool_calling', ['tool_start']],

  // 工具调用完成 → 继续思考
  ['tool_calling', 'tool_result']: ['thinking', ['tool_end']],

  // 思考完成 → 回到空闲
  ['thinking', 'llm_end']: ['idle', ['thinking_end', 'message_complete']],
}
```

### 纯函数设计

Mealy Machine 的一个重要优势是**纯函数**特性：

```typescript
// 纯函数：相同输入总是产生相同输出
function transition(state: AgentState, input: Event): [AgentState, Event[]] {
  // 无副作用，可测试，可预测
  return transitions[`${state},${input.type}`]
}

// 测试变得简单
test('user message starts thinking', () => {
  const [newState, outputs] = transition('idle', { type: 'user_message' })
  expect(newState).toBe('thinking')
  expect(outputs).toContain('thinking_start')
})
```

---

## 7.1.4 四层事件模型

AgentX 将智能体的事件组织为四个层次，从底层到高层：

### Layer 1: Stream Events（流事件）

最底层，处理实时的流式输出：

```typescript
// 文本增量
{ type: 'text_delta', delta: '你好' }
{ type: 'text_delta', delta: '，我是' }
{ type: 'text_delta', delta: 'AI助手' }

// 工具调用增量
{ type: 'tool_delta', name: 'search', delta: '{"query":' }
{ type: 'tool_delta', name: 'search', delta: '"天气"}' }
```

**用途**：实现打字机效果、进度显示

### Layer 2: State Events（状态事件）

管理会话的生命周期状态：

```typescript
// 开始思考
{ type: 'thinking_start', timestamp: 1234567890 }

// 思考结束
{ type: 'thinking_end', duration: 2500 }

// 工具调用开始/结束
{ type: 'tool_start', name: 'search', input: {...} }
{ type: 'tool_end', name: 'search', output: {...} }
```

**用途**：显示加载状态、计时、调试

### Layer 3: Message Events（消息事件）

完整的消息记录：

```typescript
// 用户消息
{
  type: 'user_message',
  id: 'msg_001',
  content: '帮我查一下明天的天气',
  timestamp: 1234567890
}

// 助手消息
{
  type: 'assistant_message',
  id: 'msg_002',
  content: '明天北京天气晴朗，气温15-22℃。',
  tool_calls: [...],
  timestamp: 1234567895
}
```

**用途**：对话历史、持久化存储

### Layer 4: Turn Events（轮次事件）

最高层，用于分析和统计：

```typescript
{
  type: 'turn_complete',
  turn_id: 'turn_001',
  user_message_id: 'msg_001',
  assistant_message_id: 'msg_002',
  duration: 5000,
  usage: {
    input_tokens: 50,
    output_tokens: 120,
    total_tokens: 170
  },
  tool_calls_count: 1
}
```

**用途**：成本分析、性能监控、用量统计

### 四层关系

```
┌─────────────────────────────────────────────┐
│  Layer 4: Turn Events（轮次统计）            │
│  ┌─────────────────────────────────────┐    │
│  │ Layer 3: Message Events（完整消息）  │    │
│  │ ┌─────────────────────────────────┐ │    │
│  │ │ Layer 2: State Events（状态变化）│ │    │
│  │ │ ┌─────────────────────────────┐ │ │    │
│  │ │ │ Layer 1: Stream（实时流）    │ │ │    │
│  │ │ └─────────────────────────────┘ │ │    │
│  │ └─────────────────────────────────┘ │    │
│  └─────────────────────────────────────┘    │
└─────────────────────────────────────────────┘

越往外层，抽象程度越高，事件频率越低
```

---

## 7.1.5 分层架构设计

AgentX 采用清晰的分层架构：

```
┌─────────────────────────────────────────────────────────┐
│                    Application Layer                     │
│                    （应用层：Portagent）                  │
├─────────────────────────────────────────────────────────┤
│                                                          │
│  ┌─────────────────┐  ┌─────────────────────────────┐  │
│  │  @agentxjs/ui   │  │    @agentxjs/network        │  │
│  │  用户界面组件    │  │    WebSocket/HTTP 通信      │  │
│  └────────┬────────┘  └──────────────┬──────────────┘  │
│           │                          │                  │
│           └──────────┬───────────────┘                  │
│                      ▼                                   │
│  ┌─────────────────────────────────────────────────┐   │
│  │              @agentxjs/runtime                   │   │
│  │              运行时基础设施                       │   │
│  │  ┌──────────┐ ┌───────────┐ ┌───────────────┐  │   │
│  │  │SystemBus │ │ Container │ │ Persistence   │  │   │
│  │  │ 事件总线  │ │ 生命周期  │ │ 数据持久化    │  │   │
│  │  └──────────┘ └───────────┘ └───────────────┘  │   │
│  └─────────────────────────┬───────────────────────┘   │
│                            ▼                            │
│  ┌─────────────────────────────────────────────────┐   │
│  │              @agentxjs/agent                     │   │
│  │              AgentEngine 核心引擎                 │   │
│  │  ┌──────────────────────────────────────────┐  │   │
│  │  │  Mealy Machine + Event Processing        │  │   │
│  │  └──────────────────────────────────────────┘  │   │
│  └─────────────────────────────────────────────────┘   │
│                                                          │
├─────────────────────────────────────────────────────────┤
│                    Environment Layer                     │
│                    （环境层：外部系统）                   │
│  ┌────────────┐  ┌────────────┐  ┌────────────────┐    │
│  │ Claude API │  │ MCP Server │  │ Other Services │    │
│  └────────────┘  └────────────┘  └────────────────┘    │
└─────────────────────────────────────────────────────────┘
```

### 各层职责

| 层 | 包 | 职责 |
|---|---|------|
| **应用层** | Portagent | 完整的用户应用 |
| **界面层** | @agentxjs/ui | React 组件 |
| **网络层** | @agentxjs/network | 通信协议 |
| **运行时层** | @agentxjs/runtime | 生命周期、持久化、事件总线 |
| **引擎层** | @agentxjs/agent | 核心状态机、事件处理 |
| **环境层** | 外部系统 | LLM API、工具、服务 |

---

## 7.1.6 与 PATEOAS 的关系

在第六章中，我们学习了 PATEOAS（Prompt as the Engine of Application State）。AgentX 正是 PATEOAS 的工程实现：

| PATEOAS 概念 | AgentX 实现 |
|-------------|------------|
| 状态嵌入提示词 | AgentEngine 的状态管理 |
| 可用操作声明 | 事件类型定义 |
| 状态转换 | Mealy Machine 转换 |
| 状态历史 | 事件日志 + Persistence |

```
PATEOAS 理论：
提示词(状态₀) → AI → 响应 + 状态₁

AgentX 实现：
Event(state₀) → AgentEngine → Event[] + state₁
```

---

## 本节要点

1. **AgentX 定位**：事件驱动的智能体开发框架和运行时平台
2. **事件驱动优势**：异步非阻塞、松耦合、可扩展、可观测
3. **Mealy Machine**：(state, input) → (state, outputs) 的纯函数状态机
4. **四层事件模型**：Stream → State → Message → Turn
5. **分层架构**：Agent → Runtime → Network/UI → Application
6. **与 PATEOAS 关系**：AgentX 是 PATEOAS 理论的工程实现

---

[上一节：本章概述](README.md) | [下一节：快速开始](7.2-快速开始.md)
